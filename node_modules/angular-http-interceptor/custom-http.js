var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Http, XHRBackend, RequestOptions, Headers } from '@angular/http';
import { Injectable, Inject } from '@angular/core';
import { Observable } from "rxjs/Observable";
import "rxjs/add/operator/do";
import "rxjs/add/observable/forkJoin";
import "rxjs/add/operator/concat";
import "rxjs/add/operator/defaultIfEmpty";
import "rxjs/add/observable/of";
import "rxjs/add/operator/catch";
import "rxjs/add/operator/skip";
import { Interceptor } from "./interfaces";
var CustomHttp = /** @class */ (function (_super) {
    __extends(CustomHttp, _super);
    function CustomHttp(injectedInterceptors, backend, defaultOptions) {
        var _this = _super.call(this, backend, defaultOptions) || this;
        // Make sure interceptors is array
        if (injectedInterceptors instanceof Array) {
            _this.interceptors = injectedInterceptors;
        }
        else {
            _this.interceptors = [injectedInterceptors];
        }
        return _this;
    }
    CustomHttp.prototype.request = function (url, options) {
        /**
             * Make sure interceptor is called with a request not a url
             */
        var request = this.mapToRequest(url, options);
        // Transform the observers for before actions, if the user do not override the method
        // it will fall back to a empty observer
        var beforeObservables = this.interceptors.map(function (_) {
            var method = _.before(request);
            if (method === null || method === undefined) {
                return Observable.empty().defaultIfEmpty("EMPTY_BEFORE");
            }
            else {
                return method.defaultIfEmpty("EMPTY_BEFORE");
            }
        });
        // Create subscribes ensure before will execute in order
        var subscribers = Observable.forkJoin(beforeObservables);
        var response = _super.prototype.request.call(this, url, options);
        var r = subscribers.concat(response).skip(1);
        return this.intercept(r);
    };
    /**
     * Unrap the observer with action for after and error for all interceptors
     * @param observable Response
     */
    /**
       * Unrap the observer with action for after and error for all interceptors
       * @param observable Response
       */
    CustomHttp.prototype.intercept = /**
       * Unrap the observer with action for after and error for all interceptors
       * @param observable Response
       */
    function (observable) {
        var _this = this;
        return observable.do(function (res) {
            _this.emitAfter(res);
        }).catch(function (err) {
            _this.emitError(err);
            return Observable.of(err);
        });
    };
    /**
     * Call all after interceptors
     * @param res response
     */
    /**
       * Call all after interceptors
       * @param res response
       */
    CustomHttp.prototype.emitAfter = /**
       * Call all after interceptors
       * @param res response
       */
    function (res) {
        for (var _i = 0, _a = this.interceptors; _i < _a.length; _i++) {
            var interceptor = _a[_i];
            interceptor.after(res);
        }
    };
    /**
     * Call all error method interceptors
     * @param error response
     */
    /**
       * Call all error method interceptors
       * @param error response
       */
    CustomHttp.prototype.emitError = /**
       * Call all error method interceptors
       * @param error response
       */
    function (error) {
        for (var _i = 0, _a = this.interceptors; _i < _a.length; _i++) {
            var interceptor = _a[_i];
            interceptor.error(error);
        }
    };
    /**
     * Transform a combination of url and options in a RequestArgs with the Url
     * @param url object request
     * @param options Options
     */
    /**
       * Transform a combination of url and options in a RequestArgs with the Url
       * @param url object request
       * @param options Options
       */
    CustomHttp.prototype.mapToRequest = /**
       * Transform a combination of url and options in a RequestArgs with the Url
       * @param url object request
       * @param options Options
       */
    function (url, options) {
        var beforeCallOption;
        if (typeof url === 'string' && options) {
            options.url = url;
            beforeCallOption = options;
        }
        else if (typeof url === 'string') {
            var newOptions = new RequestOptions({ url: url });
            newOptions.headers = new Headers();
            beforeCallOption = newOptions;
        }
        else {
            beforeCallOption = url;
        }
        return beforeCallOption;
    };
    CustomHttp.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    CustomHttp.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [Interceptor,] },] },
        { type: XHRBackend, },
        { type: RequestOptions, },
    ]; };
    return CustomHttp;
}(Http));
export { CustomHttp };

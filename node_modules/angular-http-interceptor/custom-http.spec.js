import { Component } from '@angular/core';
import { RequestOptions, HttpModule, XHRBackend, Http, ResponseOptions, Response, Request, Headers } from '@angular/http';
import { fakeAsync, TestBed, inject, tick } from "@angular/core/testing";
import { MockBackend } from "@angular/http/testing";
import { CustomHttp, InterceptorModule, INTERCEPTORS } from "./index";
import { Observable } from "rxjs/Observable";
import "rxjs/add/operator/catch";
import "rxjs/add/operator/delay";
import "rxjs/add/observable/fromPromise";
var CustomInterceptor = /** @class */ (function () {
    function CustomInterceptor(delay) {
        this.delay = delay;
    }
    // TODO use Observable.of(request).delay(this.delay) bug: https://github.com/angular/angular/issues/10127
    // TODO use Observable.of(request).delay(this.delay) bug: https://github.com/angular/angular/issues/10127
    CustomInterceptor.prototype.before = 
    // TODO use Observable.of(request).delay(this.delay) bug: https://github.com/angular/angular/issues/10127
    function (request) {
        var _this = this;
        this.lastRequest = request;
        request.headers.set("Delay " + this.delay.toString(), this.delay.toString());
        return Observable.fromPromise(new Promise(function (resolve) {
            setTimeout(function () { return resolve(request); }, _this.delay);
        }));
    };
    CustomInterceptor.prototype.after = function (response) {
        this.lastResponse = response;
        return response;
    };
    CustomInterceptor.prototype.error = function (err) {
        return err;
    };
    return CustomInterceptor;
}());
var EmptyInterceptor = /** @class */ (function () {
    function EmptyInterceptor() {
    }
    EmptyInterceptor.prototype.before = function (request) {
        return Observable.empty();
    };
    EmptyInterceptor.prototype.after = function (response) {
        this.lastResponse = response;
        return response;
    };
    EmptyInterceptor.prototype.error = function (err) {
        return err;
    };
    return EmptyInterceptor;
}());
var NullInterceptor = /** @class */ (function () {
    function NullInterceptor() {
    }
    NullInterceptor.prototype.before = function (request) {
        return null;
    };
    NullInterceptor.prototype.after = function (response) {
        this.lastResponse = response;
        return response;
    };
    NullInterceptor.prototype.error = function (err) {
        return err;
    };
    return NullInterceptor;
}());
var requestOptions = new RequestOptions();
describe('custom-http', function () {
    var customInterceptor;
    var customInterceptor2;
    beforeEach(function () {
        customInterceptor = new CustomInterceptor(0);
        customInterceptor2 = new CustomInterceptor(1);
        spyOn(customInterceptor, 'before').and.callThrough();
        spyOn(customInterceptor, 'after').and.callThrough();
        spyOn(customInterceptor, 'error').and.callThrough();
        spyOn(customInterceptor2, 'before').and.callThrough();
        spyOn(customInterceptor2, 'after').and.callThrough();
        spyOn(customInterceptor2, 'error').and.callThrough();
        //   // refine the test module by declaring the test component
        TestBed.configureTestingModule({
            imports: [
                HttpModule,
                InterceptorModule.withInterceptors([
                    { provide: INTERCEPTORS, useValue: customInterceptor, multi: true },
                    { provide: INTERCEPTORS, useValue: customInterceptor2, multi: true }
                ])
            ],
            declarations: [AppComponent],
            providers: [
                {
                    provide: RequestOptions,
                    useValue: requestOptions
                },
                {
                    provide: XHRBackend,
                    useClass: MockBackend
                }, {
                    provide: CustomInterceptor,
                    useValue: customInterceptor
                }
            ]
        });
    });
    it('should emit before event', fakeAsync(inject([CustomInterceptor, Http], function (interceptor, http) {
        http.get("fake");
        tick(10);
        expect(interceptor.before).toHaveBeenCalled();
    })));
    it('should emit after event', fakeAsync(inject([XHRBackend, CustomInterceptor, Http], function (backend, interceptor, http) {
        var body = JSON.stringify({ success: true });
        backend.connections.subscribe(function (connection) {
            var options = new ResponseOptions({
                body: body
            });
            connection.mockRespond(new Response(options));
        });
        // Without subscribe after is not called
        http.get("fake");
        tick(10);
        expect(interceptor.after).not.toHaveBeenCalled();
        http.get("fake").subscribe();
        tick(1);
        expect(interceptor.after).toHaveBeenCalled();
    })));
    it('should emit error event', fakeAsync(inject([XHRBackend, CustomInterceptor, Http], function (backend, interceptor, http) {
        backend.connections.subscribe(function (connection) {
            connection.mockError(new Error("Response error"));
        });
        http.get("fake").catch(function (e) { return Observable.of(e); }).subscribe();
        tick(10);
        expect(interceptor.error).toHaveBeenCalled();
    })));
    it('should emit error event without a catch', fakeAsync(inject([XHRBackend, CustomInterceptor, Http], function (backend, interceptor, http) {
        backend.connections.subscribe(function (connection) {
            connection.mockError(new Error("Response error"));
        });
        http.get("fake").subscribe();
        tick(10);
        expect(interceptor.error).toHaveBeenCalled();
    })));
    it('should call all interceptors', fakeAsync(inject([XHRBackend, Http], function (backend, http) {
        var body = JSON.stringify({ success: true });
        backend.connections.subscribe(function (connection) {
            var options = new ResponseOptions({
                body: body
            });
            if (connection.request.url === "error") {
                connection.mockError(new Error("error"));
            }
            else {
                connection.mockRespond(new Response(options));
            }
        });
        http.get("fake").subscribe();
        tick(10);
        expect(customInterceptor.before).toHaveBeenCalled();
        expect(customInterceptor2.before).toHaveBeenCalled();
        expect(customInterceptor.after).toHaveBeenCalled();
        expect(customInterceptor2.after).toHaveBeenCalled();
        http.get("error").subscribe();
        tick(10);
        expect(customInterceptor.error).toHaveBeenCalled();
        expect(customInterceptor2.error).toHaveBeenCalled();
    })));
    it('should let all interceptors change request', fakeAsync(inject([XHRBackend, Http], function (backend, http) {
        var body = JSON.stringify({ success: true });
        backend.connections.subscribe(function (connection) {
            var options = new ResponseOptions({
                body: body
            });
            connection.mockRespond(new Response(options));
        });
        http.get("fake").subscribe();
        tick(10);
        expect(customInterceptor.lastRequest.headers.has("Delay 0")).toBeTruthy();
        expect(customInterceptor.lastRequest.headers.has("Delay 1")).toBeTruthy();
    })));
    describe("custom-http-request", function () {
        it('should pass the request to interceptor', fakeAsync(inject([CustomInterceptor, Http], function (interceptor, http) {
            // With a request
            var request = new Request({ url: 'https://www.google.com.br' });
            http.request(request);
            tick(100);
            expect(interceptor.before).toHaveBeenCalledWith(request);
        })));
        it('should pass requestOptions from request to interceptor', fakeAsync(inject([Http], function (http) {
            // With a request
            var request = new Request({ url: 'https://www.google.com.br', headers: new Headers({ "MyHeader": "Value" }) });
            http.request(request);
            tick(100);
            expect(customInterceptor.before).toHaveBeenCalledWith(request);
        })));
        it('should pass requestOptions merged from request to interceptor', fakeAsync(inject([Http], function (http) {
            // With a request
            var url = 'https://www.google.com.br';
            var roptions = new RequestOptions();
            roptions.body = { json: 'Value' };
            roptions.method = 1;
            roptions.headers = new Headers({ "MyHeader": "Value" });
            http.request(url, roptions);
            roptions.url = url;
            tick(100);
            expect(customInterceptor.before).toHaveBeenCalledWith(roptions);
        })));
    });
});
describe('custom-http-delay-null-interceptor', function () {
    var customInterceptor;
    var customInterceptor2;
    var customInterceptor3;
    beforeEach(function () {
        customInterceptor = new CustomInterceptor(20);
        customInterceptor2 = new CustomInterceptor(15);
        customInterceptor3 = new NullInterceptor();
        spyOn(customInterceptor, 'before').and.callThrough();
        spyOn(customInterceptor, 'after').and.callThrough();
        spyOn(customInterceptor, 'error').and.callThrough();
        spyOn(customInterceptor2, 'before').and.callThrough();
        spyOn(customInterceptor2, 'after').and.callThrough();
        spyOn(customInterceptor2, 'error').and.callThrough();
        spyOn(customInterceptor3, 'before').and.callThrough();
        spyOn(customInterceptor3, 'after').and.callThrough();
        spyOn(customInterceptor3, 'error').and.callThrough();
        //   // refine the test module by declaring the test component
        TestBed.configureTestingModule({
            imports: [
                HttpModule,
                InterceptorModule.withInterceptors([
                    { provide: INTERCEPTORS, useValue: customInterceptor, multi: true },
                    { provide: INTERCEPTORS, useValue: customInterceptor2, multi: true },
                    { provide: INTERCEPTORS, useValue: customInterceptor3, multi: true }
                ])
            ],
            declarations: [AppComponent],
            providers: [
                {
                    provide: RequestOptions,
                    useValue: requestOptions
                },
                {
                    provide: XHRBackend,
                    useClass: MockBackend
                }
            ]
        });
    });
    it('should wait before interceptor method to emit a request', fakeAsync(inject([XHRBackend, Http], function (backend, http) {
        var body = JSON.stringify({ success: true });
        backend.connections.subscribe(function (connection) {
            var options = new ResponseOptions({
                body: body
            });
            connection.mockRespond(new Response(options));
        });
        http.get("fake").subscribe();
        expect(customInterceptor.before).toHaveBeenCalled();
        expect(customInterceptor2.before).toHaveBeenCalled();
        expect(customInterceptor3.before).toHaveBeenCalled();
        // 10 miliseconds pass
        tick(10);
        expect(customInterceptor.after).not.toHaveBeenCalled();
        expect(customInterceptor2.after).not.toHaveBeenCalled();
        expect(customInterceptor3.after).not.toHaveBeenCalled();
        // 16
        tick(6);
        expect(customInterceptor.after).not.toHaveBeenCalled();
        expect(customInterceptor2.after).not.toHaveBeenCalled();
        expect(customInterceptor3.after).not.toHaveBeenCalled();
        // 26 miliseconds pass
        tick(20);
        expect(customInterceptor.after).toHaveBeenCalled();
        expect(customInterceptor2.after).toHaveBeenCalled();
        expect(customInterceptor3.after).toHaveBeenCalled();
    })));
});
describe('custom-http-delay-empty-interceptor', function () {
    var customInterceptor;
    var customInterceptor2;
    var customInterceptor3;
    beforeEach(function () {
        customInterceptor = new CustomInterceptor(20);
        customInterceptor2 = new CustomInterceptor(15);
        customInterceptor3 = new EmptyInterceptor();
        spyOn(customInterceptor, 'before').and.callThrough();
        spyOn(customInterceptor, 'after').and.callThrough();
        spyOn(customInterceptor, 'error').and.callThrough();
        spyOn(customInterceptor2, 'before').and.callThrough();
        spyOn(customInterceptor2, 'after').and.callThrough();
        spyOn(customInterceptor2, 'error').and.callThrough();
        spyOn(customInterceptor3, 'before').and.callThrough();
        spyOn(customInterceptor3, 'after').and.callThrough();
        spyOn(customInterceptor3, 'error').and.callThrough();
        //   // refine the test module by declaring the test component
        TestBed.configureTestingModule({
            imports: [
                HttpModule,
                InterceptorModule.withInterceptors([
                    { provide: INTERCEPTORS, useValue: customInterceptor, multi: true },
                    { provide: INTERCEPTORS, useValue: customInterceptor2, multi: true },
                    { provide: INTERCEPTORS, useValue: customInterceptor3, multi: true }
                ])
            ],
            declarations: [AppComponent],
            providers: [
                {
                    provide: RequestOptions,
                    useValue: requestOptions
                },
                {
                    provide: XHRBackend,
                    useClass: MockBackend
                }
            ]
        });
    });
    it('should wait before interceptor method to emit a request', fakeAsync(inject([XHRBackend, Http], function (backend, http) {
        var body = JSON.stringify({ success: true });
        backend.connections.subscribe(function (connection) {
            var options = new ResponseOptions({
                body: body
            });
            connection.mockRespond(new Response(options));
        });
        http.get("fake").subscribe();
        expect(customInterceptor.before).toHaveBeenCalled();
        expect(customInterceptor2.before).toHaveBeenCalled();
        expect(customInterceptor3.before).toHaveBeenCalled();
        // 10 miliseconds pass
        tick(10);
        expect(customInterceptor.after).not.toHaveBeenCalled();
        expect(customInterceptor2.after).not.toHaveBeenCalled();
        expect(customInterceptor3.after).not.toHaveBeenCalled();
        // 16
        tick(6);
        expect(customInterceptor.after).not.toHaveBeenCalled();
        expect(customInterceptor2.after).not.toHaveBeenCalled();
        expect(customInterceptor3.after).not.toHaveBeenCalled();
        // 26 miliseconds pass
        tick(20);
        expect(customInterceptor.after).toHaveBeenCalled();
        expect(customInterceptor2.after).toHaveBeenCalled();
        expect(customInterceptor3.after).toHaveBeenCalled();
    })));
    it('should pass the response in the after method', fakeAsync(inject([XHRBackend, Http], function (backend, http) {
        var body = JSON.stringify({ success: true });
        var options = new ResponseOptions({
            body: body
        });
        var response = new Response(options);
        backend.connections.subscribe(function (connection) {
            connection.mockRespond(response);
        });
        http.get("fake").subscribe();
        tick(30);
        expect(customInterceptor.lastResponse).toEqual(response);
        expect(customInterceptor2.lastResponse).toEqual(response);
        expect(customInterceptor3.lastResponse).toEqual(response);
    })));
});
var AppComponent = /** @class */ (function () {
    function AppComponent(customHttp) {
        this.customHttp = customHttp;
    }
    AppComponent.decorators = [
        { type: Component, args: [{
                    selector: 'test-app-component',
                    template: '<h1>Hello</h1>'
                },] },
    ];
    /** @nocollapse */
    AppComponent.ctorParameters = function () { return [
        { type: CustomHttp, },
    ]; };
    return AppComponent;
}());

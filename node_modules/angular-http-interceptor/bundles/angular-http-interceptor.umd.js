(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/http'), require('rxjs/Observable'), require('rxjs/add/operator/do'), require('rxjs/add/observable/forkJoin'), require('rxjs/add/operator/concat'), require('rxjs/add/operator/defaultIfEmpty'), require('rxjs/add/observable/of'), require('rxjs/add/operator/catch'), require('rxjs/add/operator/skip')) :
    typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/http', 'rxjs/Observable', 'rxjs/add/operator/do', 'rxjs/add/observable/forkJoin', 'rxjs/add/operator/concat', 'rxjs/add/operator/defaultIfEmpty', 'rxjs/add/observable/of', 'rxjs/add/operator/catch', 'rxjs/add/operator/skip'], factory) :
    (factory((global.angularHttpInterceptor = {}),global.ng.core,global.ng.http,global.Rx));
}(this, (function (exports,core,http,Observable) { 'use strict';

    var Interceptor = /** @class */ (function () {
        function Interceptor() {
        }
        Interceptor.decorators = [
            { type: core.Injectable },
        ];
        return Interceptor;
    }());

    var __extends = (this && this.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var CustomHttp = /** @class */ (function (_super) {
        __extends(CustomHttp, _super);
        function CustomHttp(injectedInterceptors, backend, defaultOptions) {
            var _this = _super.call(this, backend, defaultOptions) || this;
            // Make sure interceptors is array
            if (injectedInterceptors instanceof Array) {
                _this.interceptors = injectedInterceptors;
            }
            else {
                _this.interceptors = [injectedInterceptors];
            }
            return _this;
        }
        CustomHttp.prototype.request = function (url, options) {
            /**
                 * Make sure interceptor is called with a request not a url
                 */
            var request = this.mapToRequest(url, options);
            // Transform the observers for before actions, if the user do not override the method
            // it will fall back to a empty observer
            var beforeObservables = this.interceptors.map(function (_) {
                var method = _.before(request);
                if (method === null || method === undefined) {
                    return Observable.Observable.empty().defaultIfEmpty("EMPTY_BEFORE");
                }
                else {
                    return method.defaultIfEmpty("EMPTY_BEFORE");
                }
            });
            // Create subscribes ensure before will execute in order
            var subscribers = Observable.Observable.forkJoin(beforeObservables);
            var response = _super.prototype.request.call(this, url, options);
            var r = subscribers.concat(response).skip(1);
            return this.intercept(r);
        };
        /**
         * Unrap the observer with action for after and error for all interceptors
         * @param observable Response
         */
        /**
           * Unrap the observer with action for after and error for all interceptors
           * @param observable Response
           */
        CustomHttp.prototype.intercept = /**
           * Unrap the observer with action for after and error for all interceptors
           * @param observable Response
           */
        function (observable) {
            var _this = this;
            return observable.do(function (res) {
                _this.emitAfter(res);
            }).catch(function (err) {
                _this.emitError(err);
                return Observable.Observable.of(err);
            });
        };
        /**
         * Call all after interceptors
         * @param res response
         */
        /**
           * Call all after interceptors
           * @param res response
           */
        CustomHttp.prototype.emitAfter = /**
           * Call all after interceptors
           * @param res response
           */
        function (res) {
            for (var _i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                var interceptor = _a[_i];
                interceptor.after(res);
            }
        };
        /**
         * Call all error method interceptors
         * @param error response
         */
        /**
           * Call all error method interceptors
           * @param error response
           */
        CustomHttp.prototype.emitError = /**
           * Call all error method interceptors
           * @param error response
           */
        function (error) {
            for (var _i = 0, _a = this.interceptors; _i < _a.length; _i++) {
                var interceptor = _a[_i];
                interceptor.error(error);
            }
        };
        /**
         * Transform a combination of url and options in a RequestArgs with the Url
         * @param url object request
         * @param options Options
         */
        /**
           * Transform a combination of url and options in a RequestArgs with the Url
           * @param url object request
           * @param options Options
           */
        CustomHttp.prototype.mapToRequest = /**
           * Transform a combination of url and options in a RequestArgs with the Url
           * @param url object request
           * @param options Options
           */
        function (url, options) {
            var beforeCallOption;
            if (typeof url === 'string' && options) {
                options.url = url;
                beforeCallOption = options;
            }
            else if (typeof url === 'string') {
                var newOptions = new http.RequestOptions({ url: url });
                newOptions.headers = new http.Headers();
                beforeCallOption = newOptions;
            }
            else {
                beforeCallOption = url;
            }
            return beforeCallOption;
        };
        CustomHttp.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        CustomHttp.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [Interceptor,] },] },
            { type: http.XHRBackend, },
            { type: http.RequestOptions, },
        ]; };
        return CustomHttp;
    }(http.Http));

    var INTERCEPTORS = new core.InjectionToken('Interceptor');
    var InterceptorModule = /** @class */ (function () {
        function InterceptorModule() {
        }
        InterceptorModule.withInterceptors = function (interceptorTypes) {
            return {
                ngModule: InterceptorModule,
                providers: [
                    interceptorTypes,
                    { provide: http.Http, useFactory: httpFactory, deps: [INTERCEPTORS, http.XHRBackend, http.RequestOptions] },
                    { provide: CustomHttp, useExisting: http.Http },
                ]
            };
        };
        InterceptorModule.decorators = [
            { type: core.NgModule, args: [{
                        providers: [
                            {
                                provide: http.Http, useFactory: httpFactory, deps: [Interceptor, http.XHRBackend, http.RequestOptions]
                            },
                            { provide: CustomHttp, useExisting: http.Http }
                        ]
                    },] },
        ];
        return InterceptorModule;
    }());
    function httpFactory(httpInterceptors, connectionBackend, requestOptions) {
        return new CustomHttp(httpInterceptors, connectionBackend, requestOptions);
    }

    exports.CustomHttp = CustomHttp;
    exports.INTERCEPTORS = INTERCEPTORS;
    exports.InterceptorModule = InterceptorModule;
    exports.httpFactory = httpFactory;
    exports.Interceptor = Interceptor;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

{"version":3,"sources":["ngx-typeahead.umd.js"],"names":["global","factory","exports","module","require","define","amd","ng","ngxTypeahead","core","common","commmon","http","Rx","Observable","prototype","this","operators","__extends","d","b","__","constructor","extendStatics","Object","create","isFunction","x","hostReportError","err","setTimeout","isObject","tryCatcher","tryCatchTarget","apply","arguments","e","errorObject","tryCatch","fn","flattenUnsubscriptionErrors","errors","reduce","errs","concat","UnsubscriptionError","isTrustedSubscriber","obj","Subscriber","rxSubscriber","toSubscriber","nextOrObserver","error","complete","empty","noop","pipeFromArray","fns","length","input","prev","getPromiseCtor","promiseCtor","config","Promise","Error","empty$1","scheduler","emptyScheduled","EMPTY","subscriber","schedule","isScheduler","value","fromArray","sub","Subscription","i","add","next","closed","subscribeToArray","scalar","result","_isScalar","of","args","_i","pop","undefined","validateNonCharKeyCode","keyCode","Key","Enter","Tab","Shift","ArrowLeft","ArrowUp","ArrowRight","ArrowDown","MacCommandLeft","MacCommandRight","MacCommandFirefox","every","codeKey","validateArrowKeys","isIndexActive","index","currentIndex","isEnterKey","event","isEscapeKey","Escape","createParamsForQuery","query","queryParamKey","customParams","searchParams","__assign$1","_a","keys","acc","param","set","HttpParams","resolveApiMethod","method","some","methodName","resolveNextIndex","stepUp","listLength","topLimit","currentResultIndex","resultIndex","bottomLimit","toJsonpSingleResult","response","toJsonpFinalResults","results","map","hasCharacters","toFormControlValue","target","resolveItemValue","item","fieldsToExtract","caseSensitive","newItem","hasOwnProperty","cur","toLowerCase","setPrototypeOf","__proto__","Array","p","_enable_super_gross_mode_that_will_cause_bad_things","useDeprecatedSynchronousErrorHandling","stack","isArray","_super","_this","call","toString","join","name","unsubscribe","_parent","_parents","_subscriptions","_unsubscribe","hasErrors","len","remove","trial","push","teardown","subscription","_addParent","tmp","subscriptions","subscriptionIndex","indexOf","splice","parent","Symbol","for","destinationOrNext","syncErrorValue","syncErrorThrown","syncErrorThrowable","isStopped","destination","trustedSubscriber","SafeSubscriber","_next","_error","_complete","_unsubscribeAndRecycle","_parentSubscriber","observerOrNext","context","bind","_context","__tryOrSetError","__tryOrUnsub","wrappedComplete","observable","subscribe","_subscribe","lift","operator","observable$$1","source","sink","_trySubscribe","forEach","resolve","reject","pipe","operations","toPromise","ObjectUnsubscribedError","SubjectSubscription","subject","observers","subscriberIndex","SubjectSubscriber","Subject","hasError","thrownError","AnonymousSubject","copy","slice","asObservable","array","assign","t","s","n","Backspace","NgxTypeAheadComponent","element","viewContainer","http$$1","cdr","showSuggestions","taUrl","taParams","taQueryParam","taApi","taApiMethod","taList","taListItemField","taListItemLabel","taDebounce","taAllowEmpty","taCaseSensitive","taDisplayOnFocus","taSelected","EventEmitter","suggestionIndex","activeResult","searchQuery","selectedItem","resultsAsItems","keydown$","keyup$","handleEsc","hideSuggestions","preventDefault","onkeyup","stopPropagation","onClick","displaySuggestions","ngOnInit","filterEnterEvent","listenAndSuggest","navigateWithArrows","renderTemplate","ngOnDestroy","createEmbeddedView","suggestionsTplRef","markForCheck","obs","filter","debounceTime","distinctUntilChanged","tap","switchMap","suggest","assignResults","updateIndex","labelForDisplay","elementObs","handleSelectSuggestion","createListSource","request","url","options","params","requestJsonp","taCallbackParamValue","requestHttp","apiMethod","callback","jsonp","markIsActive","isActive","suggestion","emit","hasItemTemplate","taItemTpl","list","sanitizedQuery","includes","decorators","type","Component","selector","styles","template","ctorParameters","ElementRef","ViewContainerRef","HttpClient","ChangeDetectorRef","propDecorators","Input","Output","ViewChild","HostListener","NgxTypeaheadModule","NgModule","declarations","CommonModule","imports","HttpClientModule","HttpClientJsonpModule","providers","Éµa","defineProperty"],"mappings":"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","file":"ngx-typeahead.umd.min.js.map","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/common/http'), require('rxjs/operators')) :\n\ttypeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/common', '@angular/common/http', 'rxjs/operators'], factory) :\n\t(factory((global.ng = global.ng || {}, global.ng.ngxTypeahead = {}),global.ng.core,global.ng.common,global.ng.commmon.http,global.Rx.Observable.prototype));\n}(this, (function (exports,core,common,http,operators) { 'use strict';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nfunction isFunction(x) {\n    return typeof x === 'function';\n}\n\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar _enable_super_gross_mode_that_will_cause_bad_things = false;\n/**\n * The global configuration object for RxJS, used to configure things\n * like what Promise contructor should used to create Promises\n */\nvar config = {\n    /**\n     * The promise constructor used by default for methods such as\n     * {@link toPromise} and {@link forEach}\n     */\n    Promise: undefined,\n    /**\n     * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n     * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n     * call in a try/catch block. It also enables producer interference, a nasty bug\n     * where a multicast can be broken for all observers by a downstream consumer with\n     * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BY TIME\n     * FOR MIGRATION REASONS.\n     */\n    set useDeprecatedSynchronousErrorHandling(value) {\n        if (value) {\n            var error = /*@__PURE__*/ new Error();\n            /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \\n' + error.stack);\n        }\n        else if (_enable_super_gross_mode_that_will_cause_bad_things) {\n            /*@__PURE__*/ console.log('RxJS: Back to a better error behavior. Thank you. <3');\n        }\n        _enable_super_gross_mode_that_will_cause_bad_things = value;\n    },\n    get useDeprecatedSynchronousErrorHandling() {\n        return _enable_super_gross_mode_that_will_cause_bad_things;\n    },\n};\n\n/**\n * Throws an error on another job so that it's picked up by the runtime's\n * uncaught error handling mechanism.\n * @param err the error to throw\n */\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nfunction hostReportError(err) {\n    setTimeout(function () { throw err; });\n}\n\n/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */\nvar empty = {\n    closed: true,\n    next: function (value) { },\n    error: function (err) {\n        if (config.useDeprecatedSynchronousErrorHandling) {\n            throw err;\n        }\n        else {\n            hostReportError(err);\n        }\n    },\n    complete: function () { }\n};\n\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nfunction isObject(x) {\n    return x != null && typeof x === 'object';\n}\n\n// typeof any so that it we don't have to cast when comparing a result to the error object\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar errorObject = { e: {} };\n\n/** PURE_IMPORTS_START _errorObject PURE_IMPORTS_END */\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    }\n    catch (e) {\n        errorObject.e = e;\n        return errorObject;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\n\n/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nvar UnsubscriptionError = /*@__PURE__*/ (function (_super) {\n    __extends(UnsubscriptionError, _super);\n    function UnsubscriptionError(errors) {\n        var _this = _super.call(this, errors ?\n            errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) { return i + 1 + \") \" + err.toString(); }).join('\\n  ') : '') || this;\n        _this.errors = errors;\n        _this.name = 'UnsubscriptionError';\n        Object.setPrototypeOf(_this, UnsubscriptionError.prototype);\n        return _this;\n    }\n    return UnsubscriptionError;\n}(Error));\n\n/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_tryCatch,_util_errorObject,_util_UnsubscriptionError PURE_IMPORTS_END */\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nvar Subscription = /*@__PURE__*/ (function () {\n    /**\n     * @param {function(): void} [unsubscribe] A function describing how to\n     * perform the disposal of resources when the `unsubscribe` method is called.\n     */\n    function Subscription(unsubscribe) {\n        /**\n         * A flag to indicate whether this Subscription has already been unsubscribed.\n         * @type {boolean}\n         */\n        this.closed = false;\n        /** @internal */\n        this._parent = null;\n        /** @internal */\n        this._parents = null;\n        /** @internal */\n        this._subscriptions = null;\n        if (unsubscribe) {\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    /**\n     * Disposes the resources held by the subscription. May, for instance, cancel\n     * an ongoing Observable execution or cancel any other type of work that\n     * started when the Subscription was created.\n     * @return {void}\n     */\n    Subscription.prototype.unsubscribe = function () {\n        var hasErrors = false;\n        var errors;\n        if (this.closed) {\n            return;\n        }\n        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this.closed = true;\n        this._parent = null;\n        this._parents = null;\n        // null out _subscriptions first so any child subscriptions that attempt\n        // to remove themselves from this subscription will noop\n        this._subscriptions = null;\n        var index = -1;\n        var len = _parents ? _parents.length : 0;\n        // if this._parent is null, then so is this._parents, and we\n        // don't have to remove ourselves from any parent subscriptions.\n        while (_parent) {\n            _parent.remove(this);\n            // if this._parents is null or index >= len,\n            // then _parent is set to null, and the loop exits\n            _parent = ++index < len && _parents[index] || null;\n        }\n        if (isFunction(_unsubscribe)) {\n            var trial = tryCatch(_unsubscribe).call(this);\n            if (trial === errorObject) {\n                hasErrors = true;\n                errors = errors || (errorObject.e instanceof UnsubscriptionError ?\n                    flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]);\n            }\n        }\n        if (isArray(_subscriptions)) {\n            index = -1;\n            len = _subscriptions.length;\n            while (++index < len) {\n                var sub = _subscriptions[index];\n                if (isObject(sub)) {\n                    var trial = tryCatch(sub.unsubscribe).call(sub);\n                    if (trial === errorObject) {\n                        hasErrors = true;\n                        errors = errors || [];\n                        var err = errorObject.e;\n                        if (err instanceof UnsubscriptionError) {\n                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n        }\n        if (hasErrors) {\n            throw new UnsubscriptionError(errors);\n        }\n    };\n    /**\n     * Adds a tear down to be called during the unsubscribe() of this\n     * Subscription.\n     *\n     * If the tear down being added is a subscription that is already\n     * unsubscribed, is the same reference `add` is being called on, or is\n     * `Subscription.EMPTY`, it will not be added.\n     *\n     * If this subscription is already in an `closed` state, the passed\n     * tear down logic will be executed immediately.\n     *\n     * @param {TeardownLogic} teardown The additional logic to execute on\n     * teardown.\n     * @return {Subscription} Returns the Subscription used or created to be\n     * added to the inner subscriptions list. This Subscription can be used with\n     * `remove()` to remove the passed teardown logic from the inner subscriptions\n     * list.\n     */\n    Subscription.prototype.add = function (teardown) {\n        if (!teardown || (teardown === Subscription.EMPTY)) {\n            return Subscription.EMPTY;\n        }\n        if (teardown === this) {\n            return this;\n        }\n        var subscription = teardown;\n        switch (typeof teardown) {\n            case 'function':\n                subscription = new Subscription(teardown);\n            case 'object':\n                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n                    return subscription;\n                }\n                else if (this.closed) {\n                    subscription.unsubscribe();\n                    return subscription;\n                }\n                else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n                    var tmp = subscription;\n                    subscription = new Subscription();\n                    subscription._subscriptions = [tmp];\n                }\n                break;\n            default:\n                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n        var subscriptions = this._subscriptions || (this._subscriptions = []);\n        subscriptions.push(subscription);\n        subscription._addParent(this);\n        return subscription;\n    };\n    /**\n     * Removes a Subscription from the internal list of subscriptions that will\n     * unsubscribe during the unsubscribe process of this Subscription.\n     * @param {Subscription} subscription The subscription to remove.\n     * @return {void}\n     */\n    Subscription.prototype.remove = function (subscription) {\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    /** @internal */\n    Subscription.prototype._addParent = function (parent) {\n        var _a = this, _parent = _a._parent, _parents = _a._parents;\n        if (!_parent || _parent === parent) {\n            // If we don't have a parent, or the new parent is the same as the\n            // current parent, then set this._parent to the new parent.\n            this._parent = parent;\n        }\n        else if (!_parents) {\n            // If there's already one parent, but not multiple, allocate an Array to\n            // store the rest of the parent Subscriptions.\n            this._parents = [parent];\n        }\n        else if (_parents.indexOf(parent) === -1) {\n            // Only add the new parent to the _parents list if it's not already there.\n            _parents.push(parent);\n        }\n    };\n    /** @nocollapse */\n    Subscription.EMPTY = (function (empty) {\n        empty.closed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n}());\nfunction flattenUnsubscriptionErrors(errors) {\n    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);\n}\n\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function')\n    ? /*@__PURE__*/ Symbol.for('rxSubscriber')\n    : '@@rxSubscriber';\n/**\n * @deprecated use rxSubscriber instead\n */\n\n/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nvar Subscriber = /*@__PURE__*/ (function (_super) {\n    __extends(Subscriber, _super);\n    /**\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n     * defined Observer or a `next` callback function.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     */\n    function Subscriber(destinationOrNext, error, complete) {\n        var _this = _super.call(this) || this;\n        /** @internal */ _this.syncErrorValue = null;\n        /** @internal */ _this.syncErrorThrown = false;\n        /** @internal */ _this.syncErrorThrowable = false;\n        _this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                _this.destination = empty;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    _this.destination = empty;\n                    break;\n                }\n                if (typeof destinationOrNext === 'object') {\n                    // HACK(benlesh): For situations where Node has multiple copies of rxjs in\n                    // node_modules, we cannot rely on `instanceof` checks\n                    if (isTrustedSubscriber(destinationOrNext)) {\n                        var trustedSubscriber = destinationOrNext[rxSubscriber]();\n                        _this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;\n                        _this.destination = trustedSubscriber;\n                        trustedSubscriber.add(_this);\n                    }\n                    else {\n                        _this.syncErrorThrowable = true;\n                        _this.destination = new SafeSubscriber(_this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                _this.syncErrorThrowable = true;\n                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);\n                break;\n        }\n        return _this;\n    }\n    Subscriber.prototype[rxSubscriber] = function () { return this; };\n    /**\n     * A static factory for a Subscriber, given a (potentially partial) definition\n     * of an Observer.\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n     * Observer represented by the given arguments.\n     * @nocollapse\n     */\n    Subscriber.create = function (next, error, complete) {\n        var subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `next` from\n     * the Observable, with a value. The Observable may call this method 0 or more\n     * times.\n     * @param {T} [value] The `next` value.\n     * @return {void}\n     */\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `error` from\n     * the Observable, with an attached {@link Error}. Notifies the Observer that\n     * the Observable has experienced an error condition.\n     * @param {any} [err] The `error` exception.\n     * @return {void}\n     */\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive a valueless notification of type\n     * `complete` from the Observable. Notifies the Observer that the Observable\n     * has finished sending push-based notifications.\n     * @return {void}\n     */\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    /** @deprecated This is an internal implementation detail, do not use. */\n    Subscriber.prototype._unsubscribeAndRecycle = function () {\n        var _a = this, _parent = _a._parent, _parents = _a._parents;\n        this._parent = null;\n        this._parents = null;\n        this.unsubscribe();\n        this.closed = false;\n        this.isStopped = false;\n        this._parent = _parent;\n        this._parents = _parents;\n        return this;\n    };\n    return Subscriber;\n}(Subscription));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SafeSubscriber = /*@__PURE__*/ (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n        var _this = _super.call(this) || this;\n        _this._parentSubscriber = _parentSubscriber;\n        var next;\n        var context = _this;\n        if (isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (observerOrNext !== empty) {\n                context = Object.create(observerOrNext);\n                if (isFunction(context.unsubscribe)) {\n                    _this.add(context.unsubscribe.bind(context));\n                }\n                context.unsubscribe = _this.unsubscribe.bind(_this);\n            }\n        }\n        _this._context = context;\n        _this._next = next;\n        _this._error = error;\n        _this._complete = complete;\n        return _this;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;\n            if (this._error) {\n                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parentSubscriber.syncErrorThrowable) {\n                this.unsubscribe();\n                if (useDeprecatedSynchronousErrorHandling) {\n                    throw err;\n                }\n                hostReportError(err);\n            }\n            else {\n                if (useDeprecatedSynchronousErrorHandling) {\n                    _parentSubscriber.syncErrorValue = err;\n                    _parentSubscriber.syncErrorThrown = true;\n                }\n                else {\n                    hostReportError(err);\n                }\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        var _this = this;\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (this._complete) {\n                var wrappedComplete = function () { return _this._complete.call(_this._context); };\n                if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(wrappedComplete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            if (config.useDeprecatedSynchronousErrorHandling) {\n                throw err;\n            }\n            else {\n                hostReportError(err);\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n        if (!config.useDeprecatedSynchronousErrorHandling) {\n            throw new Error('bad call');\n        }\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            if (config.useDeprecatedSynchronousErrorHandling) {\n                parent.syncErrorValue = err;\n                parent.syncErrorThrown = true;\n                return true;\n            }\n            else {\n                hostReportError(err);\n                return true;\n            }\n        }\n        return false;\n    };\n    /** @deprecated This is an internal implementation detail, do not use. */\n    SafeSubscriber.prototype._unsubscribe = function () {\n        var _parentSubscriber = this._parentSubscriber;\n        this._context = null;\n        this._parentSubscriber = null;\n        _parentSubscriber.unsubscribe();\n    };\n    return SafeSubscriber;\n}(Subscriber));\nfunction isTrustedSubscriber(obj) {\n    return obj instanceof Subscriber || ('syncErrorThrowable' in obj && obj[rxSubscriber]);\n}\n\n/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */\nfunction toSubscriber(nextOrObserver, error, complete) {\n    if (nextOrObserver) {\n        if (nextOrObserver instanceof Subscriber) {\n            return nextOrObserver;\n        }\n        if (nextOrObserver[rxSubscriber]) {\n            return nextOrObserver[rxSubscriber]();\n        }\n    }\n    if (!nextOrObserver && !error && !complete) {\n        return new Subscriber(empty);\n    }\n    return new Subscriber(nextOrObserver, error, complete);\n}\n\n/** Symbol.observable or a string \"@@observable\". Used for interop */\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';\n\n/* tslint:disable:no-empty */\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nfunction noop() { }\n\n/** PURE_IMPORTS_START _noop PURE_IMPORTS_END */\n/* tslint:enable:max-line-length */\n\n/* @internal */\nfunction pipeFromArray(fns) {\n    if (!fns) {\n        return noop;\n    }\n    if (fns.length === 1) {\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce(function (prev, fn) { return fn(prev); }, input);\n    };\n}\n\n/** PURE_IMPORTS_START _util_toSubscriber,_internal_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nvar Observable = /*@__PURE__*/ (function () {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    function Observable(subscribe) {\n        /** Internal implementation detail, do not use directly. */\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    Observable.prototype.lift = function (operator) {\n        var observable$$1 = new Observable();\n        observable$$1.source = this;\n        observable$$1.operator = operator;\n        return observable$$1;\n    };\n    /**\n     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n     *\n     * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n     *\n     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is\n     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling\n     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n     * thought.\n     *\n     * Apart from starting the execution of an Observable, this method allows you to listen for values\n     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n     * following ways.\n     *\n     * The first way is creating an object that implements {@link Observer} interface. It should have methods\n     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will\n     * be left uncaught.\n     *\n     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent\n     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,\n     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n     *\n     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean\n     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n     *\n     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n     * It is an Observable itself that decides when these functions will be called. For example {@link of}\n     * by default emits all its values synchronously. Always check documentation for how given Observable\n     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.\n     *\n     * @example <caption>Subscribe with an Observer</caption>\n     * const sumObserver = {\n     *   sum: 0,\n     *   next(value) {\n     *     console.log('Adding: ' + value);\n     *     this.sum = this.sum + value;\n     *   },\n     *   error() { // We actually could just remove this method,\n     *   },        // since we do not really care about errors right now.\n     *   complete() {\n     *     console.log('Sum equals: ' + this.sum);\n     *   }\n     * };\n     *\n     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n     * .subscribe(sumObserver);\n     *\n     * // Logs:\n     * // \"Adding: 1\"\n     * // \"Adding: 2\"\n     * // \"Adding: 3\"\n     * // \"Sum equals: 6\"\n     *\n     *\n     * @example <caption>Subscribe with functions</caption>\n     * let sum = 0;\n     *\n     * Rx.Observable.of(1, 2, 3)\n     * .subscribe(\n     *   function(value) {\n     *     console.log('Adding: ' + value);\n     *     sum = sum + value;\n     *   },\n     *   undefined,\n     *   function() {\n     *     console.log('Sum equals: ' + sum);\n     *   }\n     * );\n     *\n     * // Logs:\n     * // \"Adding: 1\"\n     * // \"Adding: 2\"\n     * // \"Adding: 3\"\n     * // \"Sum equals: 6\"\n     *\n     *\n     * @example <caption>Cancel a subscription</caption>\n     * const subscription = Rx.Observable.interval(1000).subscribe(\n     *   num => console.log(num),\n     *   undefined,\n     *   () => console.log('completed!') // Will not be called, even\n     * );                                // when cancelling subscription\n     *\n     *\n     * setTimeout(() => {\n     *   subscription.unsubscribe();\n     *   console.log('unsubscribed!');\n     * }, 2500);\n     *\n     * // Logs:\n     * // 0 after 1s\n     * // 1 after 2s\n     * // \"unsubscribed!\" after 2.5s\n     *\n     *\n     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n     *  Observable.\n     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n     *  the error will be thrown as unhandled.\n     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n     * @return {ISubscription} a subscription reference to the registered handlers\n     * @method subscribe\n     */\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var sink = toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            operator.call(sink, this.source);\n        }\n        else {\n            sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));\n        }\n        if (config.useDeprecatedSynchronousErrorHandling) {\n            if (sink.syncErrorThrowable) {\n                sink.syncErrorThrowable = false;\n                if (sink.syncErrorThrown) {\n                    throw sink.syncErrorValue;\n                }\n            }\n        }\n        return sink;\n    };\n    /** @deprecated This is an internal implementation detail, do not use. */\n    Observable.prototype._trySubscribe = function (sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            if (config.useDeprecatedSynchronousErrorHandling) {\n                sink.syncErrorThrown = true;\n                sink.syncErrorValue = err;\n            }\n            sink.error(err);\n        }\n    };\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    Observable.prototype.forEach = function (next, promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            // Must be declared in a separate statement to avoid a RefernceError when\n            // accessing subscription below in the closure due to Temporal Dead Zone.\n            var subscription;\n            subscription = _this.subscribe(function (value) {\n                try {\n                    next(value);\n                }\n                catch (err) {\n                    reject(err);\n                    if (subscription) {\n                        subscription.unsubscribe();\n                    }\n                }\n            }, reject, resolve);\n        });\n    };\n    /** @deprecated This is an internal implementation detail, do not use. */\n    Observable.prototype._subscribe = function (subscriber) {\n        var source = this.source;\n        return source && source.subscribe(subscriber);\n    };\n    /**\n     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     * @method Symbol.observable\n     * @return {Observable} this instance of the observable\n     */\n    Observable.prototype[observable] = function () {\n        return this;\n    };\n    /* tslint:enable:max-line-length */\n    /**\n     * Used to stitch together functional operators into a chain.\n     * @method pipe\n     * @return {Observable} the Observable result of all of the operators having\n     * been called in the order they were passed in.\n     *\n     * @example\n     *\n     * import { map, filter, scan } from 'rxjs/operators';\n     *\n     * Rx.Observable.interval(1000)\n     *   .pipe(\n     *     filter(x => x % 2 === 0),\n     *     map(x => x + x),\n     *     scan((acc, x) => acc + x)\n     *   )\n     *   .subscribe(x => console.log(x))\n     */\n    Observable.prototype.pipe = function () {\n        var operations = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operations[_i] = arguments[_i];\n        }\n        if (operations.length === 0) {\n            return this;\n        }\n        return pipeFromArray(operations)(this);\n    };\n    /* tslint:enable:max-line-length */\n    Observable.prototype.toPromise = function (promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var value;\n            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });\n        });\n    };\n    // HACK: Since TypeScript inherits static properties too, we have to\n    // fight against TypeScript here so Subject can have a different static create signature\n    /**\n     * Creates a new cold Observable by calling the Observable constructor\n     * @static true\n     * @owner Observable\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @return {Observable} a new cold observable\n     * @nocollapse\n     */\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor) {\n    if (!promiseCtor) {\n        promiseCtor = config.Promise || Promise;\n    }\n    if (!promiseCtor) {\n        throw new Error('no Promise impl found');\n    }\n    return promiseCtor;\n}\n\n/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nvar ObjectUnsubscribedError = /*@__PURE__*/ (function (_super) {\n    __extends(ObjectUnsubscribedError, _super);\n    function ObjectUnsubscribedError() {\n        var _this = _super.call(this, 'object unsubscribed') || this;\n        _this.name = 'ObjectUnsubscribedError';\n        Object.setPrototypeOf(_this, ObjectUnsubscribedError.prototype);\n        return _this;\n    }\n    return ObjectUnsubscribedError;\n}(Error));\n\n/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubjectSubscription = /*@__PURE__*/ (function (_super) {\n    __extends(SubjectSubscription, _super);\n    function SubjectSubscription(subject, subscriber) {\n        var _this = _super.call(this) || this;\n        _this.subject = subject;\n        _this.subscriber = subscriber;\n        _this.closed = false;\n        return _this;\n    }\n    SubjectSubscription.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        var subject = this.subject;\n        var observers = subject.observers;\n        this.subject = null;\n        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n            return;\n        }\n        var subscriberIndex = observers.indexOf(this.subscriber);\n        if (subscriberIndex !== -1) {\n            observers.splice(subscriberIndex, 1);\n        }\n    };\n    return SubjectSubscription;\n}(Subscription));\n\n/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */\n/**\n * @class SubjectSubscriber<T>\n */\nvar SubjectSubscriber = /*@__PURE__*/ (function (_super) {\n    __extends(SubjectSubscriber, _super);\n    function SubjectSubscriber(destination) {\n        var _this = _super.call(this, destination) || this;\n        _this.destination = destination;\n        return _this;\n    }\n    return SubjectSubscriber;\n}(Subscriber));\n/**\n * @class Subject<T>\n */\nvar Subject = /*@__PURE__*/ (function (_super) {\n    __extends(Subject, _super);\n    function Subject() {\n        var _this = _super.call(this) || this;\n        _this.observers = [];\n        _this.closed = false;\n        _this.isStopped = false;\n        _this.hasError = false;\n        _this.thrownError = null;\n        return _this;\n    }\n    Subject.prototype[rxSubscriber] = function () {\n        return new SubjectSubscriber(this);\n    };\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype.next = function (value) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        if (!this.isStopped) {\n            var observers = this.observers;\n            var len = observers.length;\n            var copy = observers.slice();\n            for (var i = 0; i < len; i++) {\n                copy[i].next(value);\n            }\n        }\n    };\n    Subject.prototype.error = function (err) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        this.hasError = true;\n        this.thrownError = err;\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].error(err);\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.complete = function () {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].complete();\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = true;\n        this.closed = true;\n        this.observers = null;\n    };\n    /** @deprecated This is an internal implementation detail, do not use. */\n    Subject.prototype._trySubscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else {\n            return _super.prototype._trySubscribe.call(this, subscriber);\n        }\n    };\n    /** @deprecated This is an internal implementation detail, do not use. */\n    Subject.prototype._subscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n            return Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            return new SubjectSubscription(this, subscriber);\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new Observable();\n        observable.source = this;\n        return observable;\n    };\n    /**@nocollapse */\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(Observable));\n/**\n * @class AnonymousSubject<T>\n */\nvar AnonymousSubject = /*@__PURE__*/ (function (_super) {\n    __extends(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        var _this = _super.call(this) || this;\n        _this.destination = destination;\n        _this.source = source;\n        return _this;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var destination = this.destination;\n        if (destination && destination.next) {\n            destination.next(value);\n        }\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var destination = this.destination;\n        if (destination && destination.error) {\n            this.destination.error(err);\n        }\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var destination = this.destination;\n        if (destination && destination.complete) {\n            this.destination.complete();\n        }\n    };\n    /** @deprecated This is an internal implementation detail, do not use. */\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var source = this.source;\n        if (source) {\n            return this.source.subscribe(subscriber);\n        }\n        else {\n            return Subscription.EMPTY;\n        }\n    };\n    return AnonymousSubject;\n}(Subject));\n\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nfunction refCount() {\n    return function refCountOperatorFunction(source) {\n        return source.lift(new RefCountOperator$1(source));\n    };\n}\nvar RefCountOperator$1 = /*@__PURE__*/ (function () {\n    function RefCountOperator(connectable) {\n        this.connectable = connectable;\n    }\n    RefCountOperator.prototype.call = function (subscriber, source) {\n        var connectable = this.connectable;\n        connectable._refCount++;\n        var refCounter = new RefCountSubscriber$1(subscriber, connectable);\n        var subscription = source.subscribe(refCounter);\n        if (!refCounter.closed) {\n            refCounter.connection = connectable.connect();\n        }\n        return subscription;\n    };\n    return RefCountOperator;\n}());\nvar RefCountSubscriber$1 = /*@__PURE__*/ (function (_super) {\n    __extends(RefCountSubscriber, _super);\n    function RefCountSubscriber(destination, connectable) {\n        var _this = _super.call(this, destination) || this;\n        _this.connectable = connectable;\n        return _this;\n    }\n    RefCountSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (!connectable) {\n            this.connection = null;\n            return;\n        }\n        this.connectable = null;\n        var refCount = connectable._refCount;\n        if (refCount <= 0) {\n            this.connection = null;\n            return;\n        }\n        connectable._refCount = refCount - 1;\n        if (refCount > 1) {\n            this.connection = null;\n            return;\n        }\n        ///\n        // Compare the local RefCountSubscriber's connection Subscription to the\n        // connection Subscription on the shared ConnectableObservable. In cases\n        // where the ConnectableObservable source synchronously emits values, and\n        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n        // execution continues to here before the RefCountOperator has a chance to\n        // supply the RefCountSubscriber with the shared connection Subscription.\n        // For example:\n        // ```\n        // Observable.range(0, 10)\n        //   .publish()\n        //   .refCount()\n        //   .take(5)\n        //   .subscribe();\n        // ```\n        // In order to account for this case, RefCountSubscriber should only dispose\n        // the ConnectableObservable's shared connection Subscription if the\n        // connection Subscription exists, *and* either:\n        //   a. RefCountSubscriber doesn't have a reference to the shared connection\n        //      Subscription yet, or,\n        //   b. RefCountSubscriber's connection Subscription reference is identical\n        //      to the shared connection Subscription\n        ///\n        var connection = this.connection;\n        var sharedConnection = connectable._connection;\n        this.connection = null;\n        if (sharedConnection && (!connection || sharedConnection === connection)) {\n            sharedConnection.unsubscribe();\n        }\n    };\n    return RefCountSubscriber;\n}(Subscriber));\n\n/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */\n/**\n * @class ConnectableObservable<T>\n */\nvar ConnectableObservable = /*@__PURE__*/ (function (_super) {\n    __extends(ConnectableObservable, _super);\n    function ConnectableObservable(source, subjectFactory) {\n        var _this = _super.call(this) || this;\n        _this.source = source;\n        _this.subjectFactory = subjectFactory;\n        _this._refCount = 0;\n        /** @internal */\n        _this._isComplete = false;\n        return _this;\n    }\n    /** @deprecated This is an internal implementation detail, do not use. */\n    ConnectableObservable.prototype._subscribe = function (subscriber) {\n        return this.getSubject().subscribe(subscriber);\n    };\n    ConnectableObservable.prototype.getSubject = function () {\n        var subject = this._subject;\n        if (!subject || subject.isStopped) {\n            this._subject = this.subjectFactory();\n        }\n        return this._subject;\n    };\n    ConnectableObservable.prototype.connect = function () {\n        var connection = this._connection;\n        if (!connection) {\n            this._isComplete = false;\n            connection = this._connection = new Subscription();\n            connection.add(this.source\n                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n            if (connection.closed) {\n                this._connection = null;\n                connection = Subscription.EMPTY;\n            }\n            else {\n                this._connection = connection;\n            }\n        }\n        return connection;\n    };\n    ConnectableObservable.prototype.refCount = function () {\n        return refCount()(this);\n    };\n    return ConnectableObservable;\n}(Observable));\n\nvar ConnectableSubscriber = /*@__PURE__*/ (function (_super) {\n    __extends(ConnectableSubscriber, _super);\n    function ConnectableSubscriber(destination, connectable) {\n        var _this = _super.call(this, destination) || this;\n        _this.connectable = connectable;\n        return _this;\n    }\n    ConnectableSubscriber.prototype._error = function (err) {\n        this._unsubscribe();\n        _super.prototype._error.call(this, err);\n    };\n    ConnectableSubscriber.prototype._complete = function () {\n        this.connectable._isComplete = true;\n        this._unsubscribe();\n        _super.prototype._complete.call(this);\n    };\n    ConnectableSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (connectable) {\n            this.connectable = null;\n            var connection = connectable._connection;\n            connectable._refCount = 0;\n            connectable._subject = null;\n            connectable._connection = null;\n            if (connection) {\n                connection.unsubscribe();\n            }\n        }\n    };\n    return ConnectableSubscriber;\n}(SubjectSubscriber));\nvar RefCountOperator = /*@__PURE__*/ (function () {\n    function RefCountOperator(connectable) {\n        this.connectable = connectable;\n    }\n    RefCountOperator.prototype.call = function (subscriber, source) {\n        var connectable = this.connectable;\n        connectable._refCount++;\n        var refCounter = new RefCountSubscriber(subscriber, connectable);\n        var subscription = source.subscribe(refCounter);\n        if (!refCounter.closed) {\n            refCounter.connection = connectable.connect();\n        }\n        return subscription;\n    };\n    return RefCountOperator;\n}());\nvar RefCountSubscriber = /*@__PURE__*/ (function (_super) {\n    __extends(RefCountSubscriber, _super);\n    function RefCountSubscriber(destination, connectable) {\n        var _this = _super.call(this, destination) || this;\n        _this.connectable = connectable;\n        return _this;\n    }\n    RefCountSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (!connectable) {\n            this.connection = null;\n            return;\n        }\n        this.connectable = null;\n        var refCount$$1 = connectable._refCount;\n        if (refCount$$1 <= 0) {\n            this.connection = null;\n            return;\n        }\n        connectable._refCount = refCount$$1 - 1;\n        if (refCount$$1 > 1) {\n            this.connection = null;\n            return;\n        }\n        ///\n        // Compare the local RefCountSubscriber's connection Subscription to the\n        // connection Subscription on the shared ConnectableObservable. In cases\n        // where the ConnectableObservable source synchronously emits values, and\n        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n        // execution continues to here before the RefCountOperator has a chance to\n        // supply the RefCountSubscriber with the shared connection Subscription.\n        // For example:\n        // ```\n        // Observable.range(0, 10)\n        //   .publish()\n        //   .refCount()\n        //   .take(5)\n        //   .subscribe();\n        // ```\n        // In order to account for this case, RefCountSubscriber should only dispose\n        // the ConnectableObservable's shared connection Subscription if the\n        // connection Subscription exists, *and* either:\n        //   a. RefCountSubscriber doesn't have a reference to the shared connection\n        //      Subscription yet, or,\n        //   b. RefCountSubscriber's connection Subscription reference is identical\n        //      to the shared connection Subscription\n        ///\n        var connection = this.connection;\n        var sharedConnection = connectable._connection;\n        this.connection = null;\n        if (sharedConnection && (!connection || sharedConnection === connection)) {\n            sharedConnection.unsubscribe();\n        }\n    };\n    return RefCountSubscriber;\n}(Subscriber));\n\n/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */\n/* tslint:enable:max-line-length */\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * <img src=\"./img/groupBy.png\" width=\"100%\">\n *\n * @example <caption>Group objects by id and return as array</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs3'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *     )\n *     .groupBy(p => p.id)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // [ { id: 1, name: 'aze1' },\n * //   { id: 1, name: 'erg1' },\n * //   { id: 1, name: 'df1' } ]\n * //\n * // [ { id: 2, name: 'sf2' },\n * //   { id: 2, name: 'dg2' },\n * //   { id: 2, name: 'sfqfb2' },\n * //   { id: 2, name: 'qsgqsfg2' } ]\n * //\n * // [ { id: 3, name: 'qfs3' } ]\n *\n * @example <caption>Pivot data on the id field</caption>\n * Observable.of<Obj>({id: 1, name: 'aze1'},\n *                    {id: 2, name: 'sf2'},\n *                    {id: 2, name: 'dg2'},\n *                    {id: 1, name: 'erg1'},\n *                    {id: 1, name: 'df1'},\n *                    {id: 2, name: 'sfqfb2'},\n *                    {id: 3, name: 'qfs1'},\n *                    {id: 2, name: 'qsgqsfg2'}\n *                   )\n *     .groupBy(p => p.id, p => p.name)\n *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n *     .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n * // { id: 3, values: [ 'qfs1' ] }\n *\n * @param {function(value: T): K} keySelector A function that extracts the key\n * for each item.\n * @param {function(value: T): R} [elementSelector] A function that extracts the\n * return element for each item.\n * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n * GroupedObservables, each of which corresponds to a unique key value and each\n * of which emits those items from the source Observable that share that key\n * value.\n * @method groupBy\n * @owner Observable\n */\n\nvar GroupByOperator = /*@__PURE__*/ (function () {\n    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {\n        this.keySelector = keySelector;\n        this.elementSelector = elementSelector;\n        this.durationSelector = durationSelector;\n        this.subjectSelector = subjectSelector;\n    }\n    GroupByOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));\n    };\n    return GroupByOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar GroupBySubscriber = /*@__PURE__*/ (function (_super) {\n    __extends(GroupBySubscriber, _super);\n    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {\n        var _this = _super.call(this, destination) || this;\n        _this.keySelector = keySelector;\n        _this.elementSelector = elementSelector;\n        _this.durationSelector = durationSelector;\n        _this.subjectSelector = subjectSelector;\n        _this.groups = null;\n        _this.attemptedToUnsubscribe = false;\n        _this.count = 0;\n        return _this;\n    }\n    GroupBySubscriber.prototype._next = function (value) {\n        var key;\n        try {\n            key = this.keySelector(value);\n        }\n        catch (err) {\n            this.error(err);\n            return;\n        }\n        this._group(value, key);\n    };\n    GroupBySubscriber.prototype._group = function (value, key) {\n        var groups = this.groups;\n        if (!groups) {\n            groups = this.groups = new Map();\n        }\n        var group = groups.get(key);\n        var element;\n        if (this.elementSelector) {\n            try {\n                element = this.elementSelector(value);\n            }\n            catch (err) {\n                this.error(err);\n            }\n        }\n        else {\n            element = value;\n        }\n        if (!group) {\n            group = (this.subjectSelector ? this.subjectSelector() : new Subject());\n            groups.set(key, group);\n            var groupedObservable = new GroupedObservable(key, group, this);\n            this.destination.next(groupedObservable);\n            if (this.durationSelector) {\n                var duration = void 0;\n                try {\n                    duration = this.durationSelector(new GroupedObservable(key, group));\n                }\n                catch (err) {\n                    this.error(err);\n                    return;\n                }\n                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n            }\n        }\n        if (!group.closed) {\n            group.next(element);\n        }\n    };\n    GroupBySubscriber.prototype._error = function (err) {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.error(err);\n            });\n            groups.clear();\n        }\n        this.destination.error(err);\n    };\n    GroupBySubscriber.prototype._complete = function () {\n        var groups = this.groups;\n        if (groups) {\n            groups.forEach(function (group, key) {\n                group.complete();\n            });\n            groups.clear();\n        }\n        this.destination.complete();\n    };\n    GroupBySubscriber.prototype.removeGroup = function (key) {\n        this.groups.delete(key);\n    };\n    GroupBySubscriber.prototype.unsubscribe = function () {\n        if (!this.closed) {\n            this.attemptedToUnsubscribe = true;\n            if (this.count === 0) {\n                _super.prototype.unsubscribe.call(this);\n            }\n        }\n    };\n    return GroupBySubscriber;\n}(Subscriber));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar GroupDurationSubscriber = /*@__PURE__*/ (function (_super) {\n    __extends(GroupDurationSubscriber, _super);\n    function GroupDurationSubscriber(key, group, parent) {\n        var _this = _super.call(this, group) || this;\n        _this.key = key;\n        _this.group = group;\n        _this.parent = parent;\n        return _this;\n    }\n    GroupDurationSubscriber.prototype._next = function (value) {\n        this.complete();\n    };\n    /** @deprecated This is an internal implementation detail, do not use. */\n    GroupDurationSubscriber.prototype._unsubscribe = function () {\n        var _a = this, parent = _a.parent, key = _a.key;\n        this.key = this.parent = null;\n        if (parent) {\n            parent.removeGroup(key);\n        }\n    };\n    return GroupDurationSubscriber;\n}(Subscriber));\n/**\n * An Observable representing values belonging to the same group represented by\n * a common key. The values emitted by a GroupedObservable come from the source\n * Observable. The common key is available as the field `key` on a\n * GroupedObservable instance.\n *\n * @class GroupedObservable<K, T>\n */\nvar GroupedObservable = /*@__PURE__*/ (function (_super) {\n    __extends(GroupedObservable, _super);\n    /** @deprecated Do not construct this type. Internal use only */\n    function GroupedObservable(key, groupSubject, refCountSubscription) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.groupSubject = groupSubject;\n        _this.refCountSubscription = refCountSubscription;\n        return _this;\n    }\n    /** @deprecated This is an internal implementation detail, do not use. */\n    GroupedObservable.prototype._subscribe = function (subscriber) {\n        var subscription = new Subscription();\n        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;\n        if (refCountSubscription && !refCountSubscription.closed) {\n            subscription.add(new InnerRefCountSubscription(refCountSubscription));\n        }\n        subscription.add(groupSubject.subscribe(subscriber));\n        return subscription;\n    };\n    return GroupedObservable;\n}(Observable));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerRefCountSubscription = /*@__PURE__*/ (function (_super) {\n    __extends(InnerRefCountSubscription, _super);\n    function InnerRefCountSubscription(parent) {\n        var _this = _super.call(this) || this;\n        _this.parent = parent;\n        parent.count++;\n        return _this;\n    }\n    InnerRefCountSubscription.prototype.unsubscribe = function () {\n        var parent = this.parent;\n        if (!parent.closed && !this.closed) {\n            _super.prototype.unsubscribe.call(this);\n            parent.count -= 1;\n            if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n                parent.unsubscribe();\n            }\n        }\n    };\n    return InnerRefCountSubscription;\n}(Subscription));\n\n/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */\n/**\n * @class BehaviorSubject<T>\n */\nvar BehaviorSubject = /*@__PURE__*/ (function (_super) {\n    __extends(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        var _this = _super.call(this) || this;\n        _this._value = _value;\n        return _this;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @deprecated This is an internal implementation detail, do not use. */\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        if (subscription && !subscription.closed) {\n            subscriber.next(this._value);\n        }\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        if (this.hasError) {\n            throw this.thrownError;\n        }\n        else if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else {\n            return this._value;\n        }\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, this._value = value);\n    };\n    return BehaviorSubject;\n}(Subject));\n\n/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nvar Action = /*@__PURE__*/ (function (_super) {\n    __extends(Action, _super);\n    function Action(scheduler, work) {\n        return _super.call(this) || this;\n    }\n    /**\n     * Schedules this action on its parent Scheduler for execution. May be passed\n     * some context object, `state`. May happen at some point in the future,\n     * according to the `delay` parameter, if specified.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler.\n     * @return {void}\n     */\n    Action.prototype.schedule = function (state, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        return this;\n    };\n    return Action;\n}(Subscription));\n\n/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsyncAction = /*@__PURE__*/ (function (_super) {\n    __extends(AsyncAction, _super);\n    function AsyncAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        _this.pending = false;\n        return _this;\n    }\n    AsyncAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (this.closed) {\n            return this;\n        }\n        // Always replace the current state with the new state.\n        this.state = state;\n        var id = this.id;\n        var scheduler = this.scheduler;\n        //\n        // Important implementation note:\n        //\n        // Actions only execute once by default, unless rescheduled from within the\n        // scheduled callback. This allows us to implement single and repeat\n        // actions via the same code path, without adding API surface area, as well\n        // as mimic traditional recursion but across asynchronous boundaries.\n        //\n        // However, JS runtimes and timers distinguish between intervals achieved by\n        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n        // serial `setTimeout` calls can be individually delayed, which delays\n        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n        // guarantee the interval callback will be invoked more precisely to the\n        // interval period, regardless of load.\n        //\n        // Therefore, we use `setInterval` to schedule single and repeat actions.\n        // If the action reschedules itself with the same delay, the interval is not\n        // canceled. If the action doesn't reschedule, or reschedules with a\n        // different delay, the interval will be canceled after scheduled callback\n        // execution.\n        //\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        // Set the pending flag indicating that this action has been scheduled, or\n        // has recursively rescheduled itself.\n        this.pending = true;\n        this.delay = delay;\n        // If this action has already an async Id, don't request a new one.\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    };\n    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        return setInterval(scheduler.flush.bind(scheduler, this), delay);\n    };\n    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        // If this action is rescheduled with the same delay time, don't clear the interval id.\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        // Otherwise, if the action's delay time is different from the current delay,\n        // or the action has been rescheduled before it's executed, clear the interval id\n        return clearInterval(id) && undefined || undefined;\n    };\n    /**\n     * Immediately executes this action and the `work` it contains.\n     * @return {any}\n     */\n    AsyncAction.prototype.execute = function (state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        var error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            // Dequeue if the action didn't reschedule itself. Don't call\n            // unsubscribe(), because the action could reschedule later.\n            // For example:\n            // ```\n            // scheduler.schedule(function doWork(counter) {\n            //   /* ... I'm a busy worker bee ... */\n            //   var originalAction = this;\n            //   /* wait 100ms before rescheduling the action */\n            //   setTimeout(function () {\n            //     originalAction.schedule(counter + 1);\n            //   }, 100);\n            // }, 1000);\n            // ```\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    };\n    AsyncAction.prototype._execute = function (state, delay) {\n        var errored = false;\n        var errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    };\n    /** @deprecated This is an internal implementation detail, do not use. */\n    AsyncAction.prototype._unsubscribe = function () {\n        var id = this.id;\n        var scheduler = this.scheduler;\n        var actions = scheduler.actions;\n        var index = actions.indexOf(this);\n        this.work = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n        this.delay = null;\n    };\n    return AsyncAction;\n}(Action));\n\n/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar QueueAction = /*@__PURE__*/ (function (_super) {\n    __extends(QueueAction, _super);\n    function QueueAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        return _this;\n    }\n    QueueAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (delay > 0) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    };\n    QueueAction.prototype.execute = function (state, delay) {\n        return (delay > 0 || this.closed) ?\n            _super.prototype.execute.call(this, state, delay) :\n            this._execute(state, delay);\n    };\n    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        // If delay exists and is greater than 0, or if the delay is null (the\n        // action wasn't rescheduled) but was originally scheduled as an async\n        // action, then recycle as an async action.\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        // Otherwise flush the scheduler starting with this action.\n        return scheduler.flush(this);\n    };\n    return QueueAction;\n}(AsyncAction));\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}\n */\nvar Scheduler = /*@__PURE__*/ (function () {\n    function Scheduler(SchedulerAction, now) {\n        if (now === void 0) {\n            now = Scheduler.now;\n        }\n        this.SchedulerAction = SchedulerAction;\n        this.now = now;\n    }\n    /**\n     * Schedules a function, `work`, for execution. May happen at some point in\n     * the future, according to the `delay` parameter, if specified. May be passed\n     * some context object, `state`, which will be passed to the `work` function.\n     *\n     * The given arguments will be processed an stored as an Action object in a\n     * queue of actions.\n     *\n     * @param {function(state: ?T): ?Subscription} work A function representing a\n     * task, or some unit of work to be executed by the Scheduler.\n     * @param {number} [delay] Time to wait before executing the work, where the\n     * time unit is implicit and defined by the Scheduler itself.\n     * @param {T} [state] Some contextual data that the `work` function uses when\n     * called by the Scheduler.\n     * @return {Subscription} A subscription in order to be able to unsubscribe\n     * the scheduled work.\n     */\n    Scheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        return new this.SchedulerAction(this, work).schedule(state, delay);\n    };\n    /** @nocollapse */\n    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };\n    return Scheduler;\n}());\n\n/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */\nvar AsyncScheduler = /*@__PURE__*/ (function (_super) {\n    __extends(AsyncScheduler, _super);\n    function AsyncScheduler(SchedulerAction, now) {\n        if (now === void 0) {\n            now = Scheduler.now;\n        }\n        var _this = _super.call(this, SchedulerAction, function () {\n            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {\n                return AsyncScheduler.delegate.now();\n            }\n            else {\n                return now();\n            }\n        }) || this;\n        _this.actions = [];\n        /**\n         * A flag to indicate whether the Scheduler is currently executing a batch of\n         * queued actions.\n         * @type {boolean}\n         * @deprecated internal use only\n         */\n        _this.active = false;\n        /**\n         * An internal ID used to track the latest asynchronous task such as those\n         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n         * others.\n         * @type {any}\n         * @deprecated internal use only\n         */\n        _this.scheduled = undefined;\n        return _this;\n    }\n    AsyncScheduler.prototype.schedule = function (work, delay, state) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n            return AsyncScheduler.delegate.schedule(work, delay, state);\n        }\n        else {\n            return _super.prototype.schedule.call(this, work, delay, state);\n        }\n    };\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift()); // exhaust the scheduler queue\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler));\n\n/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */\nvar QueueScheduler = /*@__PURE__*/ (function (_super) {\n    __extends(QueueScheduler, _super);\n    function QueueScheduler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return QueueScheduler;\n}(AsyncScheduler));\n\n/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * @examples <caption>Schedule recursively first, then do something</caption>\n *\n * Rx.Scheduler.queue.schedule(() => {\n *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n *\n *\n * @example <caption>Reschedule itself recursively</caption>\n *\n * Rx.Scheduler.queue.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n *\n *\n * @static true\n * @name queue\n * @owner Scheduler\n */\nvar queue = /*@__PURE__*/ new QueueScheduler(QueueAction);\n\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\n/**\n * The same Observable instance returned by any call to {@link empty} without a\n * {@link Scheduler}. It is preferrable to use this over `empty()`.\n */\nvar EMPTY = /*@__PURE__*/ new Observable(function (subscriber) { return subscriber.complete(); });\n/**\n * Creates an Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.\n * </span>\n *\n * <img src=\"./img/empty.png\" width=\"100%\">\n *\n * This static operator is useful for creating a simple Observable that only\n * emits the complete notification. It can be used for composing with other\n * Observables, such as in a {@link mergeMap}.\n *\n * @example <caption>Emit the number 7, then complete.</caption>\n * var result = Rx.Observable.empty().startWith(7);\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n * var interval = Rx.Observable.interval(1000);\n * var result = interval.mergeMap(x =>\n *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval eg(0,1,2,3,...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1 print abc\n * // if x % 2 is not equal to 1 nothing will be output\n *\n * @see {@link create}\n * @see {@link never}\n * @see {@link of}\n * @see {@link throw}\n *\n * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n * the emission of the complete notification.\n * @return {Observable} An \"empty\" Observable: emits only the complete\n * notification.\n * @static true\n * @name empty\n * @owner Observable\n * @deprecated Deprecated in favor of using EMPTY constant.\n */\nfunction empty$1(scheduler) {\n    return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\nfunction emptyScheduled(scheduler) {\n    return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });\n}\n\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nfunction isScheduler(value) {\n    return value && typeof value.schedule === 'function';\n}\n\n/**\n * Subscribes to an ArrayLike with a subscriber\n * @param array The array or array-like to subscribe to\n */\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar subscribeToArray = function (array) {\n    return function (subscriber) {\n        for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {\n            subscriber.next(array[i]);\n        }\n        if (!subscriber.closed) {\n            subscriber.complete();\n        }\n    };\n};\n\n/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToArray PURE_IMPORTS_END */\nfunction fromArray(input, scheduler) {\n    if (!scheduler) {\n        return new Observable(subscribeToArray(input));\n    }\n    else {\n        return new Observable(function (subscriber) {\n            var sub = new Subscription();\n            var i = 0;\n            sub.add(scheduler.schedule(function () {\n                if (i === input.length) {\n                    subscriber.complete();\n                    return;\n                }\n                subscriber.next(input[i++]);\n                if (!subscriber.closed) {\n                    sub.add(this.schedule());\n                }\n            }));\n            return sub;\n        });\n    }\n}\n\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\nfunction scalar(value) {\n    var result = new Observable(function (subscriber) {\n        subscriber.next(value);\n        subscriber.complete();\n    });\n    result._isScalar = true;\n    result.value = value;\n    return result;\n}\n\n/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_empty,_scalar PURE_IMPORTS_END */\nfunction of() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var scheduler = args[args.length - 1];\n    if (isScheduler(scheduler)) {\n        args.pop();\n    }\n    else {\n        scheduler = undefined;\n    }\n    switch (args.length) {\n        case 0:\n            return empty$1(scheduler);\n        case 1:\n            return scheduler ? fromArray(args, scheduler) : scalar(args[0]);\n        default:\n            return fromArray(args, scheduler);\n    }\n}\n\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\n/**\n * Creates an Observable that emits no items to the Observer and immediately\n * emits an error notification.\n *\n * <span class=\"informal\">Just emits 'error', and nothing else.\n * </span>\n *\n * <img src=\"./img/throw.png\" width=\"100%\">\n *\n * This static operator is useful for creating a simple Observable that only\n * emits the error notification. It can be used for composing with other\n * Observables, such as in a {@link mergeMap}.\n *\n * @example <caption>Emit the number 7, then emit an error.</caption>\n * import { throwError, concat, of } from 'rxjs/create';\n *\n * const result = concat(of(7), throwError(new Error('oops!')));\n * result.subscribe(x => console.log(x), e => console.error(e));\n *\n * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>\n * import { throwError, interval, of } from 'rxjs/create';\n * import { mergeMap } from 'rxjs/operators';\n *\n * interval(1000).pipe(\n *   mergeMap(x => x === 13 ?\n *     throwError('Thirteens are bad') :\n *     of('a', 'b', 'c')\n *   )\n * ).subscribe(x => console.log(x), e => console.error(e));\n *\n * @see {@link create}\n * @see {@link empty}\n * @see {@link never}\n * @see {@link of}\n *\n * @param {any} error The particular Error to pass to the error notification.\n * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n * the emission of the error notification.\n * @return {Observable} An error Observable: emits only the error notification\n * using the given error argument.\n * @static true\n * @name throw\n * @owner Observable\n */\nfunction throwError(error, scheduler) {\n    if (!scheduler) {\n        return new Observable(function (subscriber) { return subscriber.error(error); });\n    }\n    else {\n        return new Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });\n    }\n}\nfunction dispatch(_a) {\n    var error = _a.error, subscriber = _a.subscriber;\n    subscriber.error(error);\n}\n\n/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n *\n * @class Notification<T>\n */\nvar Notification = /*@__PURE__*/ (function () {\n    function Notification(kind, value, error) {\n        this.kind = kind;\n        this.value = value;\n        this.error = error;\n        this.hasValue = kind === 'N';\n    }\n    /**\n     * Delivers to the given `observer` the value wrapped by this Notification.\n     * @param {Observer} observer\n     * @return\n     */\n    Notification.prototype.observe = function (observer) {\n        switch (this.kind) {\n            case 'N':\n                return observer.next && observer.next(this.value);\n            case 'E':\n                return observer.error && observer.error(this.error);\n            case 'C':\n                return observer.complete && observer.complete();\n        }\n    };\n    /**\n     * Given some {@link Observer} callbacks, deliver the value represented by the\n     * current Notification to the correctly corresponding callback.\n     * @param {function(value: T): void} next An Observer `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.do = function (next, error, complete) {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return next && next(this.value);\n            case 'E':\n                return error && error(this.error);\n            case 'C':\n                return complete && complete();\n        }\n    };\n    /**\n     * Takes an Observer or its individual callback functions, and calls `observe`\n     * or `do` methods accordingly.\n     * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n     * the `next` callback.\n     * @param {function(err: any): void} [error] An Observer `error` callback.\n     * @param {function(): void} [complete] An Observer `complete` callback.\n     * @return {any}\n     */\n    Notification.prototype.accept = function (nextOrObserver, error, complete) {\n        if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n            return this.observe(nextOrObserver);\n        }\n        else {\n            return this.do(nextOrObserver, error, complete);\n        }\n    };\n    /**\n     * Returns a simple Observable that just delivers the notification represented\n     * by this Notification instance.\n     * @return {any}\n     */\n    Notification.prototype.toObservable = function () {\n        var kind = this.kind;\n        switch (kind) {\n            case 'N':\n                return of(this.value);\n            case 'E':\n                return throwError(this.error);\n            case 'C':\n                return empty$1();\n        }\n        throw new Error('unexpected notification kind value');\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `next` from a\n     * given value.\n     * @param {T} value The `next` value.\n     * @return {Notification<T>} The \"next\" Notification representing the\n     * argument.\n     * @nocollapse\n     */\n    Notification.createNext = function (value) {\n        if (typeof value !== 'undefined') {\n            return new Notification('N', value);\n        }\n        return Notification.undefinedValueNotification;\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `error` from a\n     * given error.\n     * @param {any} [err] The `error` error.\n     * @return {Notification<T>} The \"error\" Notification representing the\n     * argument.\n     * @nocollapse\n     */\n    Notification.createError = function (err) {\n        return new Notification('E', undefined, err);\n    };\n    /**\n     * A shortcut to create a Notification instance of the type `complete`.\n     * @return {Notification<any>} The valueless \"complete\" Notification.\n     * @nocollapse\n     */\n    Notification.createComplete = function () {\n        return Notification.completeNotification;\n    };\n    Notification.completeNotification = new Notification('C');\n    Notification.undefinedValueNotification = new Notification('N', undefined);\n    return Notification;\n}());\n\n/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */\n/**\n *\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>\n * const intervals = Rx.Observable.interval(10); // Intervals are scheduled\n *                                               // with async scheduler by default...\n *\n * intervals\n * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame\n * .subscribe(val => {                           // scheduler to ensure smooth animation.\n *   someDiv.style.height = val + 'px';\n * });\n *\n * @see {@link delay}\n *\n * @param {SchedulerLike} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n * but with provided scheduler.\n *\n * @method observeOn\n * @owner Observable\n */\n\nvar ObserveOnOperator = /*@__PURE__*/ (function () {\n    function ObserveOnOperator(scheduler, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    ObserveOnOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n    };\n    return ObserveOnOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ObserveOnSubscriber = /*@__PURE__*/ (function (_super) {\n    __extends(ObserveOnSubscriber, _super);\n    function ObserveOnSubscriber(destination, scheduler, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        var _this = _super.call(this, destination) || this;\n        _this.scheduler = scheduler;\n        _this.delay = delay;\n        return _this;\n    }\n    /** @nocollapse */\n    ObserveOnSubscriber.dispatch = function (arg) {\n        var notification = arg.notification, destination = arg.destination;\n        notification.observe(destination);\n        this.unsubscribe();\n    };\n    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n    };\n    ObserveOnSubscriber.prototype._next = function (value) {\n        this.scheduleMessage(Notification.createNext(value));\n    };\n    ObserveOnSubscriber.prototype._error = function (err) {\n        this.scheduleMessage(Notification.createError(err));\n    };\n    ObserveOnSubscriber.prototype._complete = function () {\n        this.scheduleMessage(Notification.createComplete());\n    };\n    return ObserveOnSubscriber;\n}(Subscriber));\nvar ObserveOnMessage = /*@__PURE__*/ (function () {\n    function ObserveOnMessage(notification, destination) {\n        this.notification = notification;\n        this.destination = destination;\n    }\n    return ObserveOnMessage;\n}());\n\n/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */\n/**\n * @class ReplaySubject<T>\n */\nvar ReplaySubject = /*@__PURE__*/ (function (_super) {\n    __extends(ReplaySubject, _super);\n    function ReplaySubject(bufferSize, windowTime, scheduler) {\n        if (bufferSize === void 0) {\n            bufferSize = Number.POSITIVE_INFINITY;\n        }\n        if (windowTime === void 0) {\n            windowTime = Number.POSITIVE_INFINITY;\n        }\n        var _this = _super.call(this) || this;\n        _this.scheduler = scheduler;\n        _this._events = [];\n        _this._infiniteTimeWindow = false;\n        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        _this._windowTime = windowTime < 1 ? 1 : windowTime;\n        if (windowTime === Number.POSITIVE_INFINITY) {\n            _this._infiniteTimeWindow = true;\n            _this.next = _this.nextInfiniteTimeWindow;\n        }\n        else {\n            _this.next = _this.nextTimeWindow;\n        }\n        return _this;\n    }\n    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {\n        var _events = this._events;\n        _events.push(value);\n        // Since this method is invoked in every next() call than the buffer\n        // can overgrow the max size only by one item\n        if (_events.length > this._bufferSize) {\n            _events.shift();\n        }\n        _super.prototype.next.call(this, value);\n    };\n    ReplaySubject.prototype.nextTimeWindow = function (value) {\n        this._events.push(new ReplayEvent(this._getNow(), value));\n        this._trimBufferThenGetEvents();\n        _super.prototype.next.call(this, value);\n    };\n    /** @deprecated This is an internal implementation detail, do not use. */\n    ReplaySubject.prototype._subscribe = function (subscriber) {\n        // When `_infiniteTimeWindow === true` then the buffer is already trimmed\n        var _infiniteTimeWindow = this._infiniteTimeWindow;\n        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n        var scheduler = this.scheduler;\n        var len = _events.length;\n        var subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else if (this.isStopped || this.hasError) {\n            subscription = Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n        }\n        if (_infiniteTimeWindow) {\n            for (var i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i]);\n            }\n        }\n        else {\n            for (var i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i].value);\n            }\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    };\n    ReplaySubject.prototype._getNow = function () {\n        return (this.scheduler || queue).now();\n    };\n    ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n        var now = this._getNow();\n        var _bufferSize = this._bufferSize;\n        var _windowTime = this._windowTime;\n        var _events = this._events;\n        var eventsCount = _events.length;\n        var spliceCount = 0;\n        // Trim events that fall out of the time window.\n        // Start at the front of the list. Break early once\n        // we encounter an event that falls within the window.\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    };\n    return ReplaySubject;\n}(Subject));\nvar ReplayEvent = /*@__PURE__*/ (function () {\n    function ReplayEvent(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n    return ReplayEvent;\n}());\n\n/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */\n/**\n * @class AsyncSubject<T>\n */\nvar AsyncSubject = /*@__PURE__*/ (function (_super) {\n    __extends(AsyncSubject, _super);\n    function AsyncSubject() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.value = null;\n        _this.hasNext = false;\n        _this.hasCompleted = false;\n        return _this;\n    }\n    /** @deprecated This is an internal implementation detail, do not use. */\n    AsyncSubject.prototype._subscribe = function (subscriber) {\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription.EMPTY;\n        }\n        else if (this.hasCompleted && this.hasNext) {\n            subscriber.next(this.value);\n            subscriber.complete();\n            return Subscription.EMPTY;\n        }\n        return _super.prototype._subscribe.call(this, subscriber);\n    };\n    AsyncSubject.prototype.next = function (value) {\n        if (!this.hasCompleted) {\n            this.value = value;\n            this.hasNext = true;\n        }\n    };\n    AsyncSubject.prototype.error = function (error) {\n        if (!this.hasCompleted) {\n            _super.prototype.error.call(this, error);\n        }\n    };\n    AsyncSubject.prototype.complete = function () {\n        this.hasCompleted = true;\n        if (this.hasNext) {\n            _super.prototype.next.call(this, this.value);\n        }\n        _super.prototype.complete.call(this);\n    };\n    return AsyncSubject;\n}(Subject));\n\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar nextHandle = 1;\nvar tasksByHandle = {};\nfunction runIfPresent(handle) {\n    var cb = tasksByHandle[handle];\n    if (cb) {\n        cb();\n    }\n}\nvar Immediate = {\n    setImmediate: function (cb) {\n        var handle = nextHandle++;\n        tasksByHandle[handle] = cb;\n        Promise.resolve().then(function () { return runIfPresent(handle); });\n        return handle;\n    },\n    clearImmediate: function (handle) {\n        delete tasksByHandle[handle];\n    },\n};\n\n/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AsapAction = /*@__PURE__*/ (function (_super) {\n    __extends(AsapAction, _super);\n    function AsapAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        return _this;\n    }\n    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        // If delay is greater than 0, request as an async action.\n        if (delay !== null && delay > 0) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        // Push the action to the end of the scheduler queue.\n        scheduler.actions.push(this);\n        // If a microtask has already been scheduled, don't schedule another\n        // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n        // the current scheduled microtask id.\n        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));\n    };\n    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        // If delay exists and is greater than 0, or if the delay is null (the\n        // action wasn't rescheduled) but was originally scheduled as an async\n        // action, then recycle as an async action.\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n        }\n        // If the scheduler queue is empty, cancel the requested microtask and\n        // set the scheduled flag to undefined so the next AsapAction will schedule\n        // its own.\n        if (scheduler.actions.length === 0) {\n            Immediate.clearImmediate(id);\n            scheduler.scheduled = undefined;\n        }\n        // Return undefined so the action knows to request a new async id if it's rescheduled.\n        return undefined;\n    };\n    return AsapAction;\n}(AsyncAction));\n\n/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */\nvar AsapScheduler = /*@__PURE__*/ (function (_super) {\n    __extends(AsapScheduler, _super);\n    function AsapScheduler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AsapScheduler.prototype.flush = function (action) {\n        this.active = true;\n        this.scheduled = undefined;\n        var actions = this.actions;\n        var error;\n        var index = -1;\n        var count = actions.length;\n        action = action || actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsapScheduler;\n}(AsyncScheduler));\n\n/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */\n/**\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asap` scheduler behaves the same as {@link async} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asap` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asap` scheduler is your best bet.\n *\n * @example <caption>Compare async and asap scheduler</caption>\n *\n * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...\n * Rx.Scheduler.asap.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n *\n * @static true\n * @name asap\n * @owner Scheduler\n */\nvar asap = /*@__PURE__*/ new AsapScheduler(AsapAction);\n\n/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asap} scheduler.\n *\n * @example <caption>Use async scheduler to delay task</caption>\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n *\n *\n * @example <caption>Use async scheduler to repeat task in intervals</caption>\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\nvar async = /*@__PURE__*/ new AsyncScheduler(AsyncAction);\n\n/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar AnimationFrameAction = /*@__PURE__*/ (function (_super) {\n    __extends(AnimationFrameAction, _super);\n    function AnimationFrameAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        return _this;\n    }\n    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        // If delay is greater than 0, request as an async action.\n        if (delay !== null && delay > 0) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        // Push the action to the end of the scheduler queue.\n        scheduler.actions.push(this);\n        // If an animation frame has already been requested, don't request another\n        // one. If an animation frame hasn't been requested yet, request one. Return\n        // the current animation frame request id.\n        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));\n    };\n    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        // If delay exists and is greater than 0, or if the delay is null (the\n        // action wasn't rescheduled) but was originally scheduled as an async\n        // action, then recycle as an async action.\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n        }\n        // If the scheduler queue is empty, cancel the requested animation frame and\n        // set the scheduled flag to undefined so the next AnimationFrameAction will\n        // request its own.\n        if (scheduler.actions.length === 0) {\n            cancelAnimationFrame(id);\n            scheduler.scheduled = undefined;\n        }\n        // Return undefined so the action knows to request a new async id if it's rescheduled.\n        return undefined;\n    };\n    return AnimationFrameAction;\n}(AsyncAction));\n\n/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */\nvar AnimationFrameScheduler = /*@__PURE__*/ (function (_super) {\n    __extends(AnimationFrameScheduler, _super);\n    function AnimationFrameScheduler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AnimationFrameScheduler.prototype.flush = function (action) {\n        this.active = true;\n        this.scheduled = undefined;\n        var actions = this.actions;\n        var error;\n        var index = -1;\n        var count = actions.length;\n        action = action || actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AnimationFrameScheduler;\n}(AsyncScheduler));\n\n/** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */\n/**\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link async} scheduler\n * behaviour.\n *\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * @example <caption>Schedule div height animation</caption>\n * const div = document.querySelector('.some-div');\n *\n * Rx.Scheduler.animationFrame.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see .some-div element growing in height\n *\n *\n * @static true\n * @name animationFrame\n * @owner Scheduler\n */\nvar animationFrame = /*@__PURE__*/ new AnimationFrameScheduler(AnimationFrameAction);\n\n/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */\nvar VirtualTimeScheduler = /*@__PURE__*/ (function (_super) {\n    __extends(VirtualTimeScheduler, _super);\n    function VirtualTimeScheduler(SchedulerAction, maxFrames) {\n        if (SchedulerAction === void 0) {\n            SchedulerAction = VirtualAction;\n        }\n        if (maxFrames === void 0) {\n            maxFrames = Number.POSITIVE_INFINITY;\n        }\n        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;\n        _this.maxFrames = maxFrames;\n        _this.frame = 0;\n        _this.index = -1;\n        return _this;\n    }\n    /**\n     * Prompt the Scheduler to execute all of its queued actions, therefore\n     * clearing its queue.\n     * @return {void}\n     */\n    VirtualTimeScheduler.prototype.flush = function () {\n        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;\n        var error, action;\n        while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        }\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    VirtualTimeScheduler.frameTimeFactor = 10;\n    return VirtualTimeScheduler;\n}(AsyncScheduler));\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar VirtualAction = /*@__PURE__*/ (function (_super) {\n    __extends(VirtualAction, _super);\n    function VirtualAction(scheduler, work, index) {\n        if (index === void 0) {\n            index = scheduler.index += 1;\n        }\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        _this.index = index;\n        _this.active = true;\n        _this.index = scheduler.index = index;\n        return _this;\n    }\n    VirtualAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        if (!this.id) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.active = false;\n        // If an action is rescheduled, we save allocations by mutating its state,\n        // pushing it to the end of the scheduler queue, and recycling the action.\n        // But since the VirtualTimeScheduler is used for testing, VirtualActions\n        // must be immutable so they can be inspected later.\n        var action = new VirtualAction(this.scheduler, this.work);\n        this.add(action);\n        return action.schedule(state, delay);\n    };\n    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        this.delay = scheduler.frame + delay;\n        var actions = scheduler.actions;\n        actions.push(this);\n        actions.sort(VirtualAction.sortActions);\n        return true;\n    };\n    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) {\n            delay = 0;\n        }\n        return undefined;\n    };\n    VirtualAction.prototype._execute = function (state, delay) {\n        if (this.active === true) {\n            return _super.prototype._execute.call(this, state, delay);\n        }\n    };\n    VirtualAction.sortActions = function (a, b) {\n        if (a.delay === b.delay) {\n            if (a.index === b.index) {\n                return 0;\n            }\n            else if (a.index > b.index) {\n                return 1;\n            }\n            else {\n                return -1;\n            }\n        }\n        else if (a.delay > b.delay) {\n            return 1;\n        }\n        else {\n            return -1;\n        }\n    };\n    return VirtualAction;\n}(AsyncAction));\n\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\n/**\n * Tests to see if the object is an RxJS {@link Observable}\n * @param obj the object to test\n */\n\n/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nvar ArgumentOutOfRangeError = /*@__PURE__*/ (function (_super) {\n    __extends(ArgumentOutOfRangeError, _super);\n    function ArgumentOutOfRangeError() {\n        var _this = _super.call(this, 'argument out of range') || this;\n        _this.name = 'ArgumentOutOfRangeError';\n        Object.setPrototypeOf(_this, ArgumentOutOfRangeError.prototype);\n        return _this;\n    }\n    return ArgumentOutOfRangeError;\n}(Error));\n\n/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n *\n * @class EmptyError\n */\nvar EmptyError = /*@__PURE__*/ (function (_super) {\n    __extends(EmptyError, _super);\n    function EmptyError() {\n        var _this = _super.call(this, 'no elements in sequence') || this;\n        _this.name = 'EmptyError';\n        Object.setPrototypeOf(_this, EmptyError.prototype);\n        return _this;\n    }\n    return EmptyError;\n}(Error));\n\n/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */\n/**\n * An error thrown when duetime elapses.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\nvar TimeoutError = /*@__PURE__*/ (function (_super) {\n    __extends(TimeoutError, _super);\n    function TimeoutError() {\n        var _this = _super.call(this, 'Timeout has occurred') || this;\n        Object.setPrototypeOf(_this, TimeoutError.prototype);\n        return _this;\n    }\n    return TimeoutError;\n}(Error));\n\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\n\nvar MapOperator = /*@__PURE__*/ (function () {\n    function MapOperator(project, thisArg) {\n        this.project = project;\n        this.thisArg = thisArg;\n    }\n    MapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n    };\n    return MapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapSubscriber = /*@__PURE__*/ (function (_super) {\n    __extends(MapSubscriber, _super);\n    function MapSubscriber(destination, project, thisArg) {\n        var _this = _super.call(this, destination) || this;\n        _this.project = project;\n        _this.count = 0;\n        _this.thisArg = thisArg || _this;\n        return _this;\n    }\n    // NOTE: This looks unoptimized, but it's actually purposefully NOT\n    // using try/catch optimizations.\n    MapSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.project.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return MapSubscriber;\n}(Subscriber));\n\n/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_isArray,_util_isScheduler PURE_IMPORTS_END */\n// tslint:enable:max-line-length\n/**\n * Converts a callback API to a function that returns an Observable.\n *\n * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\n * it will return a function `g` that when called as `g(x)` will output an\n * Observable.</span>\n *\n * `bindCallback` is not an operator because its input and output are not\n * Observables. The input is a function `func` with some parameters, the\n * last parameter must be a callback function that `func` calls when it is\n * done.\n *\n * The output of `bindCallback` is a function that takes the same parameters\n * as `func`, except the last one (the callback). When the output function\n * is called with arguments it will return an Observable. If function `func`\n * calls its callback with one argument the Observable will emit that value.\n * If on the other hand the callback is called with multiple values the resulting\n * Observable will emit an array with said values as arguments.\n *\n * It is very important to remember that input function `func` is not called\n * when the output function is, but rather when the Observable returned by the output\n * function is subscribed. This means if `func` makes an AJAX request, that request\n * will be made every time someone subscribes to the resulting Observable, but not before.\n *\n * The last optional parameter - {@link Scheduler} - can be used to control when the call\n * to `func` happens after someone subscribes to Observable, as well as when results\n * passed to callback will be emitted. By default, the subscription to  an Observable calls `func`\n * synchronously, but using `Scheduler.async` as the last parameter will defer the call to `func`,\n * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you use the async Scheduler\n * and call `subscribe` on the output Observable all function calls that are currently executing\n * will end before `func` is invoked.\n *\n * By default results passed to the callback are emitted immediately after `func` invokes the callback.\n * In particular, if the callback is called synchronously the subscription of the resulting Observable\n * will call the `next` function synchronously as well.  If you want to defer that call,\n * you may use `Scheduler.async` just as before.  This means that by using `Scheduler.async` you can\n * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.\n *\n * Note that the Observable created by the output function will always emit a single value\n * and then complete immediately. If `func` calls the callback multiple times, values from subsequent\n * calls will not appear in the stream. If you need to listen for multiple calls,\n *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.\n *\n * If `func` depends on some context (`this` property) and is not already bound the context of `func`\n * will be the context that the output function has at call time. In particular, if `func`\n * is called as a method of some objec and if `func` is not already bound, in order to preserve the context\n * it is recommended that the context of the output function is set to that object as well.\n *\n * If the input function calls its callback in the \"node style\" (i.e. first argument to callback is\n * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}\n * provides convenient error handling and probably is a better choice.\n * `bindCallback` will treat such functions the same as any other and error parameters\n * (whether passed or not) will always be interpreted as regular callback argument.\n *\n *\n * @example <caption>Convert jQuery's getJSON to an Observable API</caption>\n * // Suppose we have jQuery.getJSON('/my/url', callback)\n * var getJSONAsObservable = bindCallback(jQuery.getJSON);\n * var result = getJSONAsObservable('/my/url');\n * result.subscribe(x => console.log(x), e => console.error(e));\n *\n *\n * @example <caption>Receive an array of arguments passed to a callback</caption>\n * someFunction((a, b, c) => {\n *   console.log(a); // 5\n *   console.log(b); // 'some string'\n *   console.log(c); // {someProperty: 'someValue'}\n * });\n *\n * const boundSomeFunction = bindCallback(someFunction);\n * boundSomeFunction().subscribe(values => {\n *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]\n * });\n *\n *\n * @example <caption>Compare behaviour with and without async Scheduler</caption>\n * function iCallMyCallbackSynchronously(cb) {\n *   cb();\n * }\n *\n * const boundSyncFn = bindCallback(iCallMyCallbackSynchronously);\n * const boundAsyncFn = bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);\n *\n * boundSyncFn().subscribe(() => console.log('I was sync!'));\n * boundAsyncFn().subscribe(() => console.log('I was async!'));\n * console.log('This happened...');\n *\n * // Logs:\n * // I was sync!\n * // This happened...\n * // I was async!\n *\n *\n * @example <caption>Use bindCallback on an object method</caption>\n * const boundMethod = bindCallback(someObject.methodWithCallback);\n * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject\n * .subscribe(subscriber);\n *\n *\n * @see {@link bindNodeCallback}\n * @see {@link from}\n * @see {@link fromPromise}\n *\n * @param {function} func A function with a callback as the last parameter.\n * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n * callbacks.\n * @return {function(...params: *): Observable} A function which returns the\n * Observable that delivers the same values the callback would deliver.\n * @name bindCallback\n */\n\n/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_isScheduler,_util_isArray PURE_IMPORTS_END */\n/**\n * Converts a Node.js-style callback API to a function that returns an\n * Observable.\n *\n * <span class=\"informal\">It's just like {@link bindCallback}, but the\n * callback is expected to be of type `callback(error, result)`.</span>\n *\n * `bindNodeCallback` is not an operator because its input and output are not\n * Observables. The input is a function `func` with some parameters, but the\n * last parameter must be a callback function that `func` calls when it is\n * done. The callback function is expected to follow Node.js conventions,\n * where the first argument to the callback is an error object, signaling\n * whether call was successful. If that object is passed to callback, it means\n * something went wrong.\n *\n * The output of `bindNodeCallback` is a function that takes the same\n * parameters as `func`, except the last one (the callback). When the output\n * function is called with arguments, it will return an Observable.\n * If `func` calls its callback with error parameter present, Observable will\n * error with that value as well. If error parameter is not passed, Observable will emit\n * second parameter. If there are more parameters (third and so on),\n * Observable will emit an array with all arguments, except first error argument.\n *\n * Note that `func` will not be called at the same time output function is,\n * but rather whenever resulting Observable is subscribed. By default call to\n * `func` will happen synchronously after subscription, but that can be changed\n * with proper {@link Scheduler} provided as optional third parameter. Scheduler\n * can also control when values from callback will be emitted by Observable.\n * To find out more, check out documentation for {@link bindCallback}, where\n * Scheduler works exactly the same.\n *\n * As in {@link bindCallback}, context (`this` property) of input function will be set to context\n * of returned function, when it is called.\n *\n * After Observable emits value, it will complete immediately. This means\n * even if `func` calls callback again, values from second and consecutive\n * calls will never appear on the stream. If you need to handle functions\n * that call callbacks multiple times, check out {@link fromEvent} or\n * {@link fromEventPattern} instead.\n *\n * Note that `bindNodeCallback` can be used in non-Node.js environments as well.\n * \"Node.js-style\" callbacks are just a convention, so if you write for\n * browsers or any other environment and API you use implements that callback style,\n * `bindNodeCallback` can be safely used on that API functions as well.\n *\n * Remember that Error object passed to callback does not have to be an instance\n * of JavaScript built-in `Error` object. In fact, it does not even have to an object.\n * Error parameter of callback function is interpreted as \"present\", when value\n * of that parameter is truthy. It could be, for example, non-zero number, non-empty\n * string or boolean `true`. In all of these cases resulting Observable would error\n * with that value. This means usually regular style callbacks will fail very often when\n * `bindNodeCallback` is used. If your Observable errors much more often then you\n * would expect, check if callback really is called in Node.js-style and, if not,\n * switch to {@link bindCallback} instead.\n *\n * Note that even if error parameter is technically present in callback, but its value\n * is falsy, it still won't appear in array emitted by Observable.\n *\n *\n * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>\n * import * as fs from 'fs';\n * var readFileAsObservable = bindNodeCallback(fs.readFile);\n * var result = readFileAsObservable('./roadNames.txt', 'utf8');\n * result.subscribe(x => console.log(x), e => console.error(e));\n *\n *\n * @example <caption>Use on function calling callback with multiple arguments</caption>\n * someFunction((err, a, b) => {\n *   console.log(err); // null\n *   console.log(a); // 5\n *   console.log(b); // \"some string\"\n * });\n * var boundSomeFunction = bindNodeCallback(someFunction);\n * boundSomeFunction()\n * .subscribe(value => {\n *   console.log(value); // [5, \"some string\"]\n * });\n *\n * @example <caption>Use on function calling callback in regular style</caption>\n * someFunction(a => {\n *   console.log(a); // 5\n * });\n * var boundSomeFunction = bindNodeCallback(someFunction);\n * boundSomeFunction()\n * .subscribe(\n *   value => {}             // never gets called\n *   err => console.log(err) // 5\n * );\n *\n *\n * @see {@link bindCallback}\n * @see {@link from}\n * @see {@link fromPromise}\n *\n * @param {function} func Function with a Node.js-style callback as the last parameter.\n * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n * callbacks.\n * @return {function(...params: *): Observable} A function which returns the\n * Observable that delivers the same values the Node.js callback would\n * deliver.\n * @name bindNodeCallback\n */\n\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar OuterSubscriber = /*@__PURE__*/ (function (_super) {\n    __extends(OuterSubscriber, _super);\n    function OuterSubscriber() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.destination.error(error);\n    };\n    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.destination.complete();\n    };\n    return OuterSubscriber;\n}(Subscriber));\n\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerSubscriber = /*@__PURE__*/ (function (_super) {\n    __extends(InnerSubscriber, _super);\n    function InnerSubscriber(parent, outerValue, outerIndex) {\n        var _this = _super.call(this) || this;\n        _this.parent = parent;\n        _this.outerValue = outerValue;\n        _this.outerIndex = outerIndex;\n        _this.index = 0;\n        return _this;\n    }\n    InnerSubscriber.prototype._next = function (value) {\n        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n    };\n    InnerSubscriber.prototype._error = function (error) {\n        this.parent.notifyError(error, this);\n        this.unsubscribe();\n    };\n    InnerSubscriber.prototype._complete = function () {\n        this.parent.notifyComplete(this);\n        this.unsubscribe();\n    };\n    return InnerSubscriber;\n}(Subscriber));\n\n/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */\nvar subscribeToPromise = function (promise) {\n    return function (subscriber) {\n        promise.then(function (value) {\n            if (!subscriber.closed) {\n                subscriber.next(value);\n                subscriber.complete();\n            }\n        }, function (err) { return subscriber.error(err); })\n            .then(null, hostReportError);\n        return subscriber;\n    };\n};\n\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nfunction getSymbolIterator() {\n    if (typeof Symbol !== 'function' || !Symbol.iterator) {\n        return '@@iterator';\n    }\n    return Symbol.iterator;\n}\nvar iterator = /*@__PURE__*/ getSymbolIterator();\n/**\n * @deprecated use {@link iterator} instead\n */\n\n/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */\nvar subscribeToIterable = function (iterable) {\n    return function (subscriber) {\n        var iterator$$1 = iterable[iterator]();\n        do {\n            var item = iterator$$1.next();\n            if (item.done) {\n                subscriber.complete();\n                break;\n            }\n            subscriber.next(item.value);\n            if (subscriber.closed) {\n                break;\n            }\n        } while (true);\n        // Finalize the iterator if it happens to be a Generator\n        if (typeof iterator$$1.return === 'function') {\n            subscriber.add(function () {\n                if (iterator$$1.return) {\n                    iterator$$1.return();\n                }\n            });\n        }\n        return subscriber;\n    };\n};\n\n/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */\n/**\n * Subscribes to an object that implements Symbol.observable with the given\n * Subscriber.\n * @param obj An object that implements Symbol.observable\n */\nvar subscribeToObservable = function (obj) {\n    return function (subscriber) {\n        var obs = obj[observable]();\n        if (typeof obs.subscribe !== 'function') {\n            // Should be caught by observable subscribe function error handling.\n            throw new TypeError('Provided object does not correctly implement Symbol.observable');\n        }\n        else {\n            return obs.subscribe(subscriber);\n        }\n    };\n};\n\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });\n\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nfunction isPromise(value) {\n    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\n\n/** PURE_IMPORTS_START _Observable,_subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */\nvar subscribeTo = function (result) {\n    if (result instanceof Observable) {\n        return function (subscriber) {\n            if (result._isScalar) {\n                subscriber.next(result.value);\n                subscriber.complete();\n                return undefined;\n            }\n            else {\n                return result.subscribe(subscriber);\n            }\n        };\n    }\n    else if (isArrayLike(result)) {\n        return subscribeToArray(result);\n    }\n    else if (isPromise(result)) {\n        return subscribeToPromise(result);\n    }\n    else if (result && typeof result[iterator] === 'function') {\n        return subscribeToIterable(result);\n    }\n    else if (result && typeof result[observable] === 'function') {\n        return subscribeToObservable(result);\n    }\n    else {\n        var value = isObject(result) ? 'an invalid object' : \"'\" + result + \"'\";\n        var msg = \"You provided \" + value + \" where a stream was expected.\"\n            + ' You can provide an Observable, Promise, Array, or Iterable.';\n        throw new TypeError(msg);\n    }\n};\n\n/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo PURE_IMPORTS_END */\nfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n    var destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n    return subscribeTo(result)(destination);\n}\n\n/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */\nvar NONE = {};\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from all the Observables passed as\n * arguments. This is done by subscribing to each Observable in order and,\n * whenever any Observable emits, collecting an array of the most recent\n * values from each Observable. So if you pass `n` Observables to operator,\n * returned Observable will always emit an array of `n` values, in order\n * corresponding to order of passed Observables (value from the first Observable\n * on the first place and so on).\n *\n * Static version of `combineLatest` accepts either an array of Observables\n * or each Observable can be put directly as an argument. Note that array of\n * Observables is good choice, if you don't know beforehand how many Observables\n * you will combine. Passing empty array will result in Observable that\n * completes immediately.\n *\n * To ensure output array has always the same length, `combineLatest` will\n * actually wait for all input Observables to emit at least once,\n * before it starts emitting results. This means if some Observable emits\n * values before other Observables started emitting, all that values but last\n * will be lost. On the other hand, is some Observable does not emit value but\n * completes, resulting Observable will complete at the same moment without\n * emitting anything, since it will be now impossible to include value from\n * completed Observable in resulting array. Also, if some input Observable does\n * not emit any value and never completes, `combineLatest` will also never emit\n * and never complete, since, again, it will wait for all streams to emit some\n * value.\n *\n * If at least one Observable was passed to `combineLatest` and all passed Observables\n * emitted something, resulting Observable will complete when all combined\n * streams complete. So even if some Observable completes, result of\n * `combineLatest` will still emit values when other Observables do. In case\n * of completed Observable, its value from now on will always be the last\n * emitted value. On the other hand, if any Observable errors, `combineLatest`\n * will error immediately as well, and all other Observables will be unsubscribed.\n *\n * `combineLatest` accepts as optional parameter `project` function, which takes\n * as arguments all values that would normally be emitted by resulting Observable.\n * `project` can return any kind of value, which will be then emitted by Observable\n * instead of default array. Note that `project` does not take as argument that array\n * of values, but values themselves. That means default `project` can be imagined\n * as function that takes all its arguments and puts them into an array.\n *\n *\n * @example <caption>Combine two timer Observables</caption>\n * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now\n * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now\n * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);\n * combinedTimers.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0] after 0.5s\n * // [1, 0] after 1s\n * // [1, 1] after 1.5s\n * // [2, 1] after 2s\n *\n *\n * @example <caption>Combine an array of Observables</caption>\n * const observables = [1, 5, 10].map(\n *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds\n * );\n * const combined = Rx.Observable.combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0, 0] immediately\n * // [1, 0, 0] after 1s\n * // [1, 5, 0] after 5s\n * // [1, 5, 10] after 10s\n *\n *\n * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} observable1 An input Observable to combine with other Observables.\n * @param {ObservableInput} observable2 An input Observable to combine with other Observables.\n * More than one input Observables may be given as arguments\n * or an array of Observables may be given as the first argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n * each input Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n */\n\nvar CombineLatestOperator = /*@__PURE__*/ (function () {\n    function CombineLatestOperator(resultSelector) {\n        this.resultSelector = resultSelector;\n    }\n    CombineLatestOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));\n    };\n    return CombineLatestOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar CombineLatestSubscriber = /*@__PURE__*/ (function (_super) {\n    __extends(CombineLatestSubscriber, _super);\n    function CombineLatestSubscriber(destination, resultSelector) {\n        var _this = _super.call(this, destination) || this;\n        _this.resultSelector = resultSelector;\n        _this.active = 0;\n        _this.values = [];\n        _this.observables = [];\n        return _this;\n    }\n    CombineLatestSubscriber.prototype._next = function (observable) {\n        this.values.push(NONE);\n        this.observables.push(observable);\n    };\n    CombineLatestSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            this.active = len;\n            this.toRespond = len;\n            for (var i = 0; i < len; i++) {\n                var observable = observables[i];\n                this.add(subscribeToResult(this, observable, observable, i));\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {\n        if ((this.active -= 1) === 0) {\n            this.destination.complete();\n        }\n    };\n    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        var values = this.values;\n        var oldVal = values[outerIndex];\n        var toRespond = !this.toRespond\n            ? 0\n            : oldVal === NONE ? --this.toRespond : this.toRespond;\n        values[outerIndex] = innerValue;\n        if (toRespond === 0) {\n            if (this.resultSelector) {\n                this._tryResultSelector(values);\n            }\n            else {\n                this.destination.next(values.slice());\n            }\n        }\n    };\n    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {\n        var result;\n        try {\n            result = this.resultSelector.apply(this, values);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return CombineLatestSubscriber;\n}(OuterSubscriber));\n\n/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */\n/** Identifies an input as being Observable (but not necessary an Rx Observable) */\n\n/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */\n/** Identifies an input as being an Iterable */\n\n/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToPromise PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator,_util_subscribeToIterable PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable,_util_subscribeToObservable PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _Observable,_util_isPromise,_util_isArrayLike,_util_isInteropObservable,_util_isIterable,_fromArray,_fromPromise,_fromIterable,_fromObservable,_util_subscribeTo PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_map,_observable_from PURE_IMPORTS_END */\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\n\nvar MergeMapOperator = /*@__PURE__*/ (function () {\n    function MergeMapOperator(project, concurrent) {\n        if (concurrent === void 0) {\n            concurrent = Number.POSITIVE_INFINITY;\n        }\n        this.project = project;\n        this.concurrent = concurrent;\n    }\n    MergeMapOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));\n    };\n    return MergeMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeMapSubscriber = /*@__PURE__*/ (function (_super) {\n    __extends(MergeMapSubscriber, _super);\n    function MergeMapSubscriber(destination, project, concurrent) {\n        if (concurrent === void 0) {\n            concurrent = Number.POSITIVE_INFINITY;\n        }\n        var _this = _super.call(this, destination) || this;\n        _this.project = project;\n        _this.concurrent = concurrent;\n        _this.hasCompleted = false;\n        _this.buffer = [];\n        _this.active = 0;\n        _this.index = 0;\n        return _this;\n    }\n    MergeMapSubscriber.prototype._next = function (value) {\n        if (this.active < this.concurrent) {\n            this._tryNext(value);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    };\n    MergeMapSubscriber.prototype._tryNext = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.active++;\n        this._innerSub(result, value, index);\n    };\n    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n        this.add(subscribeToResult(this, ish, value, index));\n    };\n    MergeMapSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeMapSubscriber;\n}(OuterSubscriber));\n\n/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * <img src=\"./img/mergeAll.png\" width=\"100%\">\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var firstOrder = higherOrder.mergeAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n * var firstOrder = higherOrder.mergeAll(2);\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\n\n/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * <img src=\"./img/concatAll.png\" width=\"100%\">\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n * var firstOrder = higherOrder.concatAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n *\n * @see {@link combineAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaust}\n * @see {@link mergeAll}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @return {Observable} An Observable emitting values from all the inner\n * Observables concatenated.\n * @method concatAll\n * @owner Observable\n */\n\n/** PURE_IMPORTS_START _util_isScheduler,_of,_from,_operators_concatAll PURE_IMPORTS_END */\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = Rx.Observable.concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n *\n * @example <caption>Concatenate an array of 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n *\n * @example <caption>Concatenate the same Observable to repeat it</caption>\n * const timer = Rx.Observable.interval(1000).take(2);\n *\n * Rx.Observable.concat(timer, timer) // concating the same Observable!\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('...and it is done!')\n * );\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // \"...and it is done!\" also after 4s\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} input1 An input Observable to concatenate with others.\n * @param {ObservableInput} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\n\n/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */\n/**\n * Creates an Observable that, on subscribe, calls an Observable factory to\n * make an Observable for each new Observer.\n *\n * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n * is subscribed.\n * </span>\n *\n * <img src=\"./img/defer.png\" width=\"100%\">\n *\n * `defer` allows you to create the Observable only when the Observer\n * subscribes, and create a fresh Observable for each Observer. It waits until\n * an Observer subscribes to it, and then it generates an Observable,\n * typically with an Observable factory function. It does this afresh for each\n * subscriber, so although each subscriber may think it is subscribing to the\n * same Observable, in fact each subscriber gets its own individual\n * Observable.\n *\n * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>\n * var clicksOrInterval = Rx.Observable.defer(function () {\n *   if (Math.random() > 0.5) {\n *     return Rx.Observable.fromEvent(document, 'click');\n *   } else {\n *     return Rx.Observable.interval(1000);\n *   }\n * });\n * clicksOrInterval.subscribe(x => console.log(x));\n *\n * // Results in the following behavior:\n * // If the result of Math.random() is greater than 0.5 it will listen\n * // for clicks anywhere on the \"document\"; when document is clicked it\n * // will log a MouseEvent object to the console. If the result is less\n * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n *\n * @see {@link create}\n *\n * @param {function(): SubscribableOrPromise} observableFactory The Observable\n * factory function to invoke for each Observer that subscribes to the output\n * Observable. May also return a Promise, which will be converted on the fly\n * to an Observable.\n * @return {Observable} An Observable whose Observers' subscriptions trigger\n * an invocation of the given Observable factory function.\n * @static true\n * @name defer\n * @owner Observable\n */\n\n/** PURE_IMPORTS_START tslib,_Observable,_util_isArray,_empty,_util_subscribeToResult,_OuterSubscriber,_operators_map PURE_IMPORTS_END */\n/* tslint:enable:max-line-length */\n/**\n * Joins last values emitted by passed Observables.\n *\n * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\n *\n * <img src=\"./img/forkJoin.png\" width=\"100%\">\n *\n * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array\n * or directly as arguments. If no input Observables are provided, resulting stream will complete\n * immediately.\n *\n * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last\n * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting\n * array will have `n` values, where first value is the last thing emitted by the first Observable,\n * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will\n * not emit more than once and it will complete after that. If you need to emit combined values not only\n * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}\n * or {@link zip} instead.\n *\n * In order for resulting array to have the same length as the number of input Observables, whenever any of\n * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well\n * and it will not emit anything either, even if it already has some last values from other Observables.\n * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,\n * unless at any point some other Observable completes without emitting value, which brings us back to\n * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments\n * have to emit something at least once and complete.\n *\n * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables\n * will be immediately unsubscribed.\n *\n * Optionally `forkJoin` accepts project function, that will be called with values which normally\n * would land in emitted array. Whatever is returned by project function, will appear in output\n * Observable instead. This means that default project can be thought of as a function that takes\n * all its arguments and puts them into an array. Note that project function will be called only\n * when output Observable is supposed to emit a result.\n *\n * @example <caption>Use forkJoin with operator emitting immediately</caption>\n * import { forkJoin, of } from 'rxjs';\n *\n * const observable = forkJoin(\n *   of(1, 2, 3, 4),\n *   of(5, 6, 7, 8)\n * );\n * observable.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('This is how it ends!')\n * );\n *\n * // Logs:\n * // [4, 8]\n * // \"This is how it ends!\"\n *\n *\n * @example <caption>Use forkJoin with operator emitting after some time</caption>\n * import { forkJoin, interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const observable = forkJoin(\n *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete\n *   interval(500).pipe(take(4)) // emit 0, 1, 2, 3 every half a second and complete\n * );\n * observable.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('This is how it ends!')\n * );\n *\n * // Logs:\n * // [2, 3] after 3 seconds\n * // \"This is how it ends!\" immediately after\n *\n *\n * @example <caption>Use forkJoin with project function</caption>\n * import { jorkJoin, interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const observable = forkJoin(\n *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete\n *   interval(500).pipe(take(4)), // emit 0, 1, 2, 3 every half a second and complete\n *   (n, m) => n + m\n * );\n * observable.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('This is how it ends!')\n * );\n *\n * // Logs:\n * // 5 after 3 seconds\n * // \"This is how it ends!\" immediately after\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n *\n * @param {...ObservableInput} sources Any number of Observables provided either as an array or as an arguments\n * passed directly to the operator.\n * @param {function} [project] Function that takes values emitted by input Observables and returns value\n * that will appear in resulting Observable instead of default array.\n * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n * or value from project function.\n */\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ForkJoinSubscriber = /*@__PURE__*/ (function (_super) {\n    __extends(ForkJoinSubscriber, _super);\n    function ForkJoinSubscriber(destination, sources) {\n        var _this = _super.call(this, destination) || this;\n        _this.sources = sources;\n        _this.completed = 0;\n        _this.haveValues = 0;\n        var len = sources.length;\n        _this.values = new Array(len);\n        for (var i = 0; i < len; i++) {\n            var source = sources[i];\n            var innerSubscription = subscribeToResult(_this, source, null, i);\n            if (innerSubscription) {\n                _this.add(innerSubscription);\n            }\n        }\n        return _this;\n    }\n    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.values[outerIndex] = innerValue;\n        if (!innerSub._hasValue) {\n            innerSub._hasValue = true;\n            this.haveValues++;\n        }\n    };\n    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {\n        var _a = this, destination = _a.destination, haveValues = _a.haveValues, values = _a.values;\n        var len = values.length;\n        if (!innerSub._hasValue) {\n            destination.complete();\n            return;\n        }\n        this.completed++;\n        if (this.completed !== len) {\n            return;\n        }\n        if (haveValues === len) {\n            destination.next(values);\n        }\n        destination.complete();\n    };\n    return ForkJoinSubscriber;\n}(OuterSubscriber));\n\n/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */\n/* tslint:enable:max-line-length */\n/**\n * Creates an Observable that emits events of a specific type coming from the\n * given event target.\n *\n * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n * EventEmitter events or others.</span>\n *\n * <img src=\"./img/fromEvent.png\" width=\"100%\">\n *\n * `fromEvent` accepts as a first argument event target, which is an object with methods\n * for registering event handler functions. As a second argument it takes string that indicates\n * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n * which are described in detail below. If your event target does not match any of the ones listed,\n * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n * handler functions have different names, but they all accept a string describing event type\n * and function itself, which will be called whenever said event happens.\n *\n * Every time resulting Observable is subscribed, event handler function will be registered\n * to event target on given event type. When that event fires, value\n * passed as a first argument to registered function will be emitted by output Observable.\n * When Observable is unsubscribed, function will be unregistered from event target.\n *\n * Note that if event target calls registered function with more than one argument, second\n * and following arguments will not appear in resulting stream. In order to get access to them,\n * you can pass to `fromEvent` optional project function, which will be called with all arguments\n * passed to event handler. Output Observable will then emit value returned by project function,\n * instead of the usual value.\n *\n * Remember that event targets listed below are checked via duck typing. It means that\n * no matter what kind of object you have and no matter what environment you work in,\n * you can safely use `fromEvent` on that object if it exposes described methods (provided\n * of course they behave as was described above). So for example if Node.js library exposes\n * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n * a good choice.\n *\n * If the API you use is more callback then event handler oriented (subscribed\n * callback function fires only once and thus there is no need to manually\n * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n * instead.\n *\n * `fromEvent` supports following types of event targets:\n *\n * **DOM EventTarget**\n *\n * This is an object with `addEventListener` and `removeEventListener` methods.\n *\n * In the browser, `addEventListener` accepts - apart from event type string and event\n * handler function arguments - optional third parameter, which is either an object or boolean,\n * both used for additional configuration how and when passed function will be called. When\n * `fromEvent` is used with event target of that type, you can provide this values\n * as third parameter as well.\n *\n * **Node.js EventEmitter**\n *\n * An object with `addListener` and `removeListener` methods.\n *\n * **JQuery-style event target**\n *\n * An object with `on` and `off` methods\n *\n * **DOM NodeList**\n *\n * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n *\n * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n * it contains and install event handler function in every of them. When returned Observable\n * is unsubscribed, function will be removed from all Nodes.\n *\n * **DOM HtmlCollection**\n *\n * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n * installed and removed in each of elements.\n *\n *\n * @example <caption>Emits clicks happening on the DOM document</caption>\n * var clicks = fromEvent(document, 'click');\n * clicks.subscribe(x => console.log(x));\n *\n * // Results in:\n * // MouseEvent object logged to console every time a click\n * // occurs on the document.\n *\n *\n * @example <caption>Use addEventListener with capture option</caption>\n * var clicksInDocument = fromEvent(document, 'click', true); // note optional configuration parameter\n *                                                                          // which will be passed to addEventListener\n * var clicksInDiv = fromEvent(someDivInDocument, 'click');\n *\n * clicksInDocument.subscribe(() => console.log('document'));\n * clicksInDiv.subscribe(() => console.log('div'));\n *\n * // By default events bubble UP in DOM tree, so normally\n * // when we would click on div in document\n * // \"div\" would be logged first and then \"document\".\n * // Since we specified optional `capture` option, document\n * // will catch event when it goes DOWN DOM tree, so console\n * // will log \"document\" and then \"div\".\n *\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n * @see {@link fromEventPattern}\n *\n * @param {FromEventTarget<T>} target The DOM EventTarget, Node.js\n * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n * @param {string} eventName The event name of interest, being emitted by the\n * `target`.\n * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n * @return {Observable<T>}\n * @name fromEvent\n */\n\n/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */\n/* tslint:enable:max-line-length */\n/**\n * Creates an Observable from an API based on addHandler/removeHandler\n * functions.\n *\n * <span class=\"informal\">Converts any addHandler/removeHandler API to an\n * Observable.</span>\n *\n * <img src=\"./img/fromEventPattern.png\" width=\"100%\">\n *\n * Creates an Observable by using the `addHandler` and `removeHandler`\n * functions to add and remove the handlers. The `addHandler` is\n * called when the output Observable is subscribed, and `removeHandler` is\n * called when the Subscription is unsubscribed.\n *\n * @example <caption>Emits clicks happening on the DOM document</caption>\n * function addClickHandler(handler) {\n *   document.addEventListener('click', handler);\n * }\n *\n * function removeClickHandler(handler) {\n *   document.removeEventListener('click', handler);\n * }\n *\n * var clicks = fromEventPattern(\n *   addClickHandler,\n *   removeClickHandler\n * );\n * clicks.subscribe(x => console.log(x));\n *\n * @see {@link from}\n * @see {@link fromEvent}\n *\n * @param {function(handler: Function): any} addHandler A function that takes\n * a `handler` function as argument and attaches it somehow to the actual\n * source of events.\n * @param {function(handler: Function, signal?: any): void} [removeHandler] An optional function that\n * takes a `handler` function as argument and removes it in case it was\n * previously attached using `addHandler`. if addHandler returns signal to teardown when remove,\n * removeHandler function will forward it.\n * @return {Observable<T>}\n * @name fromEventPattern\n */\n\n/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */\n/**\n * Decides at subscription time which Observable will actually be subscribed.\n *\n * <span class=\"informal\">`If` statement for Observables.</span>\n *\n * `if` accepts a condition function and two Observables. When\n * an Observable returned by the operator is subscribed, condition function will be called.\n * Based on what boolean it returns at that moment, consumer will subscribe either to\n * the first Observable (if condition was true) or to the second (if condition was false). Condition\n * function may also not return anything - in that case condition will be evaluated as false and\n * second Observable will be subscribed.\n *\n * Note that Observables for both cases (true and false) are optional. If condition points to an Observable that\n * was left undefined, resulting stream will simply complete immediately. That allows you to, rather\n * then controlling which Observable will be subscribed, decide at runtime if consumer should have access\n * to given Observable or not.\n *\n * If you have more complex logic that requires decision between more than two Observables, {@link defer}\n * will probably be a better choice. Actually `if` can be easily implemented with {@link defer}\n * and exists only for convenience and readability reasons.\n *\n *\n * @example <caption>Change at runtime which Observable will be subscribed</caption>\n * let subscribeToFirst;\n * const firstOrSecond = Rx.Observable.if(\n *   () => subscribeToFirst,\n *   Rx.Observable.of('first'),\n *   Rx.Observable.of('second')\n * );\n *\n * subscribeToFirst = true;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // \"first\"\n *\n * subscribeToFirst = false;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // \"second\"\n *\n *\n * @example <caption>Control an access to an Observable</caption>\n * let accessGranted;\n * const observableIfYouHaveAccess = Rx.Observable.if(\n *   () => accessGranted,\n *   Rx.Observable.of('It seems you have an access...') // Note that only one Observable is passed to the operator.\n * );\n *\n * accessGranted = true;\n * observableIfYouHaveAccess.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('The end')\n * );\n *\n * // Logs:\n * // \"It seems you have an access...\"\n * // \"The end\"\n *\n * accessGranted = false;\n * observableIfYouHaveAccess.subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('The end')\n * );\n *\n * // Logs:\n * // \"The end\"\n *\n * @see {@link defer}\n *\n * @param {function(): boolean} condition Condition which Observable should be chosen.\n * @param {Observable} [trueObservable] An Observable that will be subscribed if condition is true.\n * @param {Observable} [falseObservable] An Observable that will be subscribed if condition is false.\n * @return {Observable} Either first or second Observable, depending on condition.\n * @static true\n * @name iif\n * @owner Observable\n */\n\n/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */\n\n/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */\n/**\n * Creates an Observable that emits sequential numbers every specified\n * interval of time, on a specified IScheduler.\n *\n * <span class=\"informal\">Emits incremental numbers periodically in time.\n * </span>\n *\n * <img src=\"./img/interval.png\" width=\"100%\">\n *\n * `interval` returns an Observable that emits an infinite sequence of\n * ascending integers, with a constant interval of time of your choosing\n * between those emissions. The first emission is not sent immediately, but\n * only after the first period has passed. By default, this operator uses the\n * `async` IScheduler to provide a notion of time, but you may pass any\n * IScheduler to it.\n *\n * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>\n * var numbers = Rx.Observable.interval(1000);\n * numbers.subscribe(x => console.log(x));\n *\n * @see {@link timer}\n * @see {@link delay}\n *\n * @param {number} [period=0] The interval size in milliseconds (by default)\n * or the time unit determined by the scheduler's clock.\n * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n * the emission of values, and providing a notion of \"time\".\n * @return {Observable} An Observable that emits a sequential number each time\n * interval.\n * @static true\n * @name interval\n * @owner Observable\n */\n\n/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = Rx.Observable.merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console everytime the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits it's max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits it's max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {...ObservableInput} observables Input Observables to merge together.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} an Observable that emits items that are the result of\n * every input Observable.\n * @static true\n * @name merge\n * @owner Observable\n */\n\n/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */\n/**\n * An Observable that emits no items to the Observer and never completes.\n *\n * <img src=\"./img/never.png\" width=\"100%\">\n *\n * A simple Observable that emits neither values nor errors nor the completion\n * notification. It can be used for testing purposes or for composing with other\n * Observables. Please note that by never emitting a complete notification, this\n * Observable keeps the subscription from being disposed automatically.\n * Subscriptions need to be manually disposed.\n *\n * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>\n * function info() {\n *   console.log('Will not be called');\n * }\n * var result = NEVER.startWith(7);\n * result.subscribe(x => console.log(x), info, info);\n *\n * @see {@link create}\n * @see {@link EMPTY}\n * @see {@link of}\n * @see {@link throwError}\n */\nvar NEVER = /*@__PURE__*/ new Observable(noop);\n/**\n * @deprecated Deprecated in favor of using NEVER constant.\n */\n\n/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */\n/* tslint:enable:max-line-length */\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\">\n *\n * `onErrorResumeNext` Will subscribe to each observable source it is provided, in order.\n * If the source it's subscribed to emits an error or completes, it will move to the next source\n * without error.\n *\n * If `onErrorResumeNext` is provided no arguments, or a single, empty array, it will return {@link EMPTY}.\n *\n * `onErrorResumeNext` is basically {@link concat}, only it will continue, even if one of its\n * sources emits an error.\n *\n * Note that there is no way to handle any errors thrown by sources via the resuult of\n * `onErrorResumeNext`. If you want to handle errors thrown in any given source, you can\n * always use the {@link catchError} operator on them before passing them into `onErrorResumeNext`.\n *\n * @example <caption>Subscribe to the next Observable after map fails</caption>\n * import { onErrorResumeNext, of } from 'rxjs/create';\n * import { map } from 'rxjs/operators';\n *\n * onErrorResumeNext(\n *  of(1, 2, 3, 0).pipe(\n *    map(x => {\n *      if (x === 0) throw Error();\n *      return 10 / x;\n *    })\n *  ),\n *  of(1, 2, 3),\n * )\n * .subscribe(\n *   val => console.log(val),\n *   err => console.log(err),          // Will never be called.\n *   () => console.log('done')\n * );\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // \"done\"\n *\n * @see {@link concat}\n * @see {@link catch}\n *\n * @param {...ObservableInput} sources Observables (or anything that *is* observable) passed either directly or as an array.\n * @return {Observable} An Observable that concatenates all sources, one after the other,\n * ignoring all errors, such that any error causes it to move on to the next source.\n */\n\n/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */\n/**\n * Convert an object into an observable sequence of [key, value] pairs\n * using an optional IScheduler to enumerate the object.\n *\n * @example <caption>Converts a javascript object to an Observable</caption>\n * var obj = {\n *   foo: 42,\n *   bar: 56,\n *   baz: 78\n * };\n *\n * var source = Rx.Observable.pairs(obj);\n *\n * var subscription = source.subscribe(\n *   function (x) {\n *     console.log('Next: %s', x);\n *   },\n *   function (err) {\n *     console.log('Error: %s', err);\n *   },\n *   function () {\n *     console.log('Completed');\n *   });\n *\n * @param {Object} obj The object to inspect and turn into an\n * Observable sequence.\n * @param {Scheduler} [scheduler] An optional IScheduler to run the\n * enumeration of the input sequence on.\n * @returns {(Observable<[string, T]>)} An observable sequence of\n * [key, value] pairs from the object.\n */\n\n/** @internal */\n\n/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */\n\nvar RaceOperator = /*@__PURE__*/ (function () {\n    function RaceOperator() {\n    }\n    RaceOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new RaceSubscriber(subscriber));\n    };\n    return RaceOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar RaceSubscriber = /*@__PURE__*/ (function (_super) {\n    __extends(RaceSubscriber, _super);\n    function RaceSubscriber(destination) {\n        var _this = _super.call(this, destination) || this;\n        _this.hasFirst = false;\n        _this.observables = [];\n        _this.subscriptions = [];\n        return _this;\n    }\n    RaceSubscriber.prototype._next = function (observable) {\n        this.observables.push(observable);\n    };\n    RaceSubscriber.prototype._complete = function () {\n        var observables = this.observables;\n        var len = observables.length;\n        if (len === 0) {\n            this.destination.complete();\n        }\n        else {\n            for (var i = 0; i < len && !this.hasFirst; i++) {\n                var observable = observables[i];\n                var subscription = subscribeToResult(this, observable, observable, i);\n                if (this.subscriptions) {\n                    this.subscriptions.push(subscription);\n                }\n                this.add(subscription);\n            }\n            this.observables = null;\n        }\n    };\n    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (!this.hasFirst) {\n            this.hasFirst = true;\n            for (var i = 0; i < this.subscriptions.length; i++) {\n                if (i !== outerIndex) {\n                    var subscription = this.subscriptions[i];\n                    subscription.unsubscribe();\n                    this.remove(subscription);\n                }\n            }\n            this.subscriptions = null;\n        }\n        this.destination.next(innerValue);\n    };\n    return RaceSubscriber;\n}(OuterSubscriber));\n\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\n/**\n * Creates an Observable that emits a sequence of numbers within a specified\n * range.\n *\n * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\n *\n * <img src=\"./img/range.png\" width=\"100%\">\n *\n * `range` operator emits a range of sequential integers, in order, where you\n * select the `start` of the range and its `length`. By default, uses no\n * IScheduler and just delivers the notifications synchronously, but may use\n * an optional IScheduler to regulate those deliveries.\n *\n * @example <caption>Emits the numbers 1 to 10</caption>\n * var numbers = Rx.Observable.range(1, 10);\n * numbers.subscribe(x => console.log(x));\n *\n * @see {@link timer}\n * @see {@link interval}\n *\n * @param {number} [start=0] The value of the first integer in the sequence.\n * @param {number} [count=0] The number of sequential integers to generate.\n * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n * the emissions of the notifications.\n * @return {Observable} An Observable of numbers that emits a finite range of\n * sequential integers.\n * @static true\n * @name range\n * @owner Observable\n */\n\n/** @internal */\n\n/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */\n/**\n * Creates an Observable that starts emitting after an `initialDelay` and\n * emits ever increasing numbers after each `period` of time thereafter.\n *\n * <span class=\"informal\">Its like {@link interval}, but you can specify when\n * should the emissions start.</span>\n *\n * <img src=\"./img/timer.png\" width=\"100%\">\n *\n * `timer` returns an Observable that emits an infinite sequence of ascending\n * integers, with a constant interval of time, `period` of your choosing\n * between those emissions. The first emission happens after the specified\n * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n * operator uses the `async` IScheduler to provide a notion of time, but you\n * may pass any IScheduler to it. If `period` is not specified, the output\n * Observable emits only one value, `0`. Otherwise, it emits an infinite\n * sequence.\n *\n * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n * var numbers = Rx.Observable.timer(3000, 1000);\n * numbers.subscribe(x => console.log(x));\n *\n * @example <caption>Emits one number after five seconds</caption>\n * var numbers = Rx.Observable.timer(5000);\n * numbers.subscribe(x => console.log(x));\n *\n * @see {@link interval}\n * @see {@link delay}\n *\n * @param {number|Date} [dueTime] The initial delay time to wait before\n * emitting the first value of `0`.\n * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the\n * subsequent numbers.\n * @param {SchedulerLike} [scheduler=async] The IScheduler to use for scheduling\n * the emission of values, and providing a notion of \"time\".\n * @return {Observable} An Observable that emits a `0` after the\n * `initialDelay` and ever increasing numbers after each `period` of time\n * thereafter.\n * @static true\n * @name timer\n * @owner Observable\n */\n\n/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */\n/**\n * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.\n *\n * <span class=\"informal\">Use it when you catch yourself cleaning up after an Observable.</span>\n *\n * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.\n * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with\n * that object and should return an Observable. That Observable can use resource object during its execution.\n * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor\n * resource object will be shared in any way between subscriptions.\n *\n * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed\n * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output\n * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,\n * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which\n * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone\n * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make\n * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.\n *\n * @see {@link defer}\n *\n * @param {function(): ISubscription} resourceFactory A function which creates any resource object\n * that implements `unsubscribe` method.\n * @param {function(resource: ISubscription): Observable<T>} observableFactory A function which\n * creates an Observable, that can use injected resource object.\n * @return {Observable<T>} An Observable that behaves the same as Observable returned by `observableFactory`, but\n * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.\n */\n\n/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_OuterSubscriber,_util_subscribeToResult,_.._internal_symbol_iterator PURE_IMPORTS_END */\n/* tslint:enable:max-line-length */\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the latest parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * @example <caption>Combine age and name from different sources</caption>\n *\n * let age$ = Observable.of<number>(27, 25, 29);\n * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');\n * let isDev$ = Observable.of<boolean>(true, true, false);\n *\n * Observable\n *     .zip(age$,\n *          name$,\n *          isDev$,\n *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))\n *     .subscribe(x => console.log(x));\n *\n * // outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n *\n * @param observables\n * @return {Observable<R>}\n * @static true\n * @name zip\n * @owner Observable\n */\n\nvar ZipOperator = /*@__PURE__*/ (function () {\n    function ZipOperator(resultSelector) {\n        this.resultSelector = resultSelector;\n    }\n    ZipOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));\n    };\n    return ZipOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ZipSubscriber = /*@__PURE__*/ (function (_super) {\n    __extends(ZipSubscriber, _super);\n    function ZipSubscriber(destination, resultSelector, values) {\n        if (values === void 0) {\n            values = Object.create(null);\n        }\n        var _this = _super.call(this, destination) || this;\n        _this.iterators = [];\n        _this.active = 0;\n        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : null;\n        _this.values = values;\n        return _this;\n    }\n    ZipSubscriber.prototype._next = function (value) {\n        var iterators = this.iterators;\n        if (isArray(value)) {\n            iterators.push(new StaticArrayIterator(value));\n        }\n        else if (typeof value[iterator] === 'function') {\n            iterators.push(new StaticIterator(value[iterator]()));\n        }\n        else {\n            iterators.push(new ZipBufferIterator(this.destination, this, value));\n        }\n    };\n    ZipSubscriber.prototype._complete = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        if (len === 0) {\n            this.destination.complete();\n            return;\n        }\n        this.active = len;\n        for (var i = 0; i < len; i++) {\n            var iterator$$1 = iterators[i];\n            if (iterator$$1.stillUnsubscribed) {\n                this.add(iterator$$1.subscribe(iterator$$1, i));\n            }\n            else {\n                this.active--; // not an observable\n            }\n        }\n    };\n    ZipSubscriber.prototype.notifyInactive = function () {\n        this.active--;\n        if (this.active === 0) {\n            this.destination.complete();\n        }\n    };\n    ZipSubscriber.prototype.checkIterators = function () {\n        var iterators = this.iterators;\n        var len = iterators.length;\n        var destination = this.destination;\n        // abort if not all of them have values\n        for (var i = 0; i < len; i++) {\n            var iterator$$1 = iterators[i];\n            if (typeof iterator$$1.hasValue === 'function' && !iterator$$1.hasValue()) {\n                return;\n            }\n        }\n        var shouldComplete = false;\n        var args = [];\n        for (var i = 0; i < len; i++) {\n            var iterator$$1 = iterators[i];\n            var result = iterator$$1.next();\n            // check to see if it's completed now that you've gotten\n            // the next value.\n            if (iterator$$1.hasCompleted()) {\n                shouldComplete = true;\n            }\n            if (result.done) {\n                destination.complete();\n                return;\n            }\n            args.push(result.value);\n        }\n        if (this.resultSelector) {\n            this._tryresultSelector(args);\n        }\n        else {\n            destination.next(args);\n        }\n        if (shouldComplete) {\n            destination.complete();\n        }\n    };\n    ZipSubscriber.prototype._tryresultSelector = function (args) {\n        var result;\n        try {\n            result = this.resultSelector.apply(this, args);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return ZipSubscriber;\n}(Subscriber));\nvar StaticIterator = /*@__PURE__*/ (function () {\n    function StaticIterator(iterator$$1) {\n        this.iterator = iterator$$1;\n        this.nextResult = iterator$$1.next();\n    }\n    StaticIterator.prototype.hasValue = function () {\n        return true;\n    };\n    StaticIterator.prototype.next = function () {\n        var result = this.nextResult;\n        this.nextResult = this.iterator.next();\n        return result;\n    };\n    StaticIterator.prototype.hasCompleted = function () {\n        var nextResult = this.nextResult;\n        return nextResult && nextResult.done;\n    };\n    return StaticIterator;\n}());\nvar StaticArrayIterator = /*@__PURE__*/ (function () {\n    function StaticArrayIterator(array) {\n        this.array = array;\n        this.index = 0;\n        this.length = 0;\n        this.length = array.length;\n    }\n    StaticArrayIterator.prototype[iterator] = function () {\n        return this;\n    };\n    StaticArrayIterator.prototype.next = function (value) {\n        var i = this.index++;\n        var array = this.array;\n        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n    };\n    StaticArrayIterator.prototype.hasValue = function () {\n        return this.array.length > this.index;\n    };\n    StaticArrayIterator.prototype.hasCompleted = function () {\n        return this.array.length === this.index;\n    };\n    return StaticArrayIterator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ZipBufferIterator = /*@__PURE__*/ (function (_super) {\n    __extends(ZipBufferIterator, _super);\n    function ZipBufferIterator(destination, parent, observable) {\n        var _this = _super.call(this, destination) || this;\n        _this.parent = parent;\n        _this.observable = observable;\n        _this.stillUnsubscribed = true;\n        _this.buffer = [];\n        _this.isComplete = false;\n        return _this;\n    }\n    ZipBufferIterator.prototype[iterator] = function () {\n        return this;\n    };\n    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\n    //    this is legit because `next()` will never be called by a subscription in this case.\n    ZipBufferIterator.prototype.next = function () {\n        var buffer = this.buffer;\n        if (buffer.length === 0 && this.isComplete) {\n            return { value: null, done: true };\n        }\n        else {\n            return { value: buffer.shift(), done: false };\n        }\n    };\n    ZipBufferIterator.prototype.hasValue = function () {\n        return this.buffer.length > 0;\n    };\n    ZipBufferIterator.prototype.hasCompleted = function () {\n        return this.buffer.length === 0 && this.isComplete;\n    };\n    ZipBufferIterator.prototype.notifyComplete = function () {\n        if (this.buffer.length > 0) {\n            this.isComplete = true;\n            this.parent.notifyInactive();\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.buffer.push(innerValue);\n        this.parent.checkIterators();\n    };\n    ZipBufferIterator.prototype.subscribe = function (value, index) {\n        return subscribeToResult(this, this.observable, this, index);\n    };\n    return ZipBufferIterator;\n}(OuterSubscriber));\n\n/* Observable */\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\n\r\n\r\nvar __assign$1 = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n};\n\n/**\n * @license ngx-typeahead\n * MIT license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/** @enum {number} */\nvar Key = {\n    Backspace: 8,\n    Tab: 9,\n    Enter: 13,\n    Shift: 16,\n    Escape: 27,\n    ArrowLeft: 37,\n    ArrowRight: 39,\n    ArrowUp: 38,\n    ArrowDown: 40,\n    // http://unixpapa.com/js/key.html\n    MacCommandLeft: 91,\n    MacCommandRight: 93,\n    MacCommandFirefox: 224,\n};\nKey[Key.Backspace] = \"Backspace\";\nKey[Key.Tab] = \"Tab\";\nKey[Key.Enter] = \"Enter\";\nKey[Key.Shift] = \"Shift\";\nKey[Key.Escape] = \"Escape\";\nKey[Key.ArrowLeft] = \"ArrowLeft\";\nKey[Key.ArrowRight] = \"ArrowRight\";\nKey[Key.ArrowUp] = \"ArrowUp\";\nKey[Key.ArrowDown] = \"ArrowDown\";\nKey[Key.MacCommandLeft] = \"MacCommandLeft\";\nKey[Key.MacCommandRight] = \"MacCommandRight\";\nKey[Key.MacCommandFirefox] = \"MacCommandFirefox\";\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @param {?} keyCode\n * @return {?}\n */\nfunction validateNonCharKeyCode(keyCode) {\n    return [\n        Key.Enter,\n        Key.Tab,\n        Key.Shift,\n        Key.ArrowLeft,\n        Key.ArrowUp,\n        Key.ArrowRight,\n        Key.ArrowDown,\n        Key.MacCommandLeft,\n        Key.MacCommandRight,\n        Key.MacCommandFirefox\n    ].every(function (codeKey) { return codeKey !== keyCode; });\n}\n/**\n * @param {?} keyCode\n * @return {?}\n */\nfunction validateArrowKeys(keyCode) {\n    return keyCode === Key.ArrowDown || keyCode === Key.ArrowUp;\n}\n/**\n * @param {?} index\n * @param {?} currentIndex\n * @return {?}\n */\nfunction isIndexActive(index, currentIndex) {\n    return index === currentIndex;\n}\n/**\n * @param {?} event\n * @return {?}\n */\nfunction isEnterKey(event) {\n    return event.keyCode === Key.Enter;\n}\n/**\n * @param {?} event\n * @return {?}\n */\nfunction isEscapeKey(event) {\n    return event.keyCode === Key.Escape;\n}\n/**\n * @param {?} query\n * @param {?=} queryParamKey\n * @param {?=} customParams\n * @return {?}\n */\nfunction createParamsForQuery(query, queryParamKey, customParams) {\n    if (queryParamKey === void 0) { queryParamKey = 'q'; }\n    if (customParams === void 0) { customParams = {}; }\n    var /** @type {?} */ searchParams = __assign$1((_a = {}, _a[queryParamKey] = query, _a), customParams);\n    // tslint:disable-next-line\n    var /** @type {?} */ setParam = function (acc, param) {\n        return acc.set(param, searchParams[param]);\n    };\n    var /** @type {?} */ params = Object.keys(searchParams).reduce(setParam, new http.HttpParams());\n    return params;\n    var _a;\n}\n/**\n * @param {?=} method\n * @return {?}\n */\nfunction resolveApiMethod(method) {\n    if (method === void 0) { method = ''; }\n    var /** @type {?} */ isMethodValid = [\n        'get',\n        'post',\n        'put',\n        'delete',\n        'patch',\n        'request'\n    ].some(function (methodName) { return method === methodName; });\n    var /** @type {?} */ apiMethod = isMethodValid ? method : 'get';\n    return apiMethod;\n}\n/**\n * @param {?} currentIndex\n * @param {?} stepUp\n * @param {?=} listLength\n * @return {?}\n */\nfunction resolveNextIndex(currentIndex, stepUp, listLength) {\n    if (listLength === void 0) { listLength = 10; }\n    var /** @type {?} */ step = stepUp ? 1 : -1;\n    var /** @type {?} */ topLimit = listLength - 1;\n    var /** @type {?} */ bottomLimit = 0;\n    var /** @type {?} */ currentResultIndex = currentIndex + step;\n    var /** @type {?} */ resultIndex = currentResultIndex;\n    if (currentResultIndex === topLimit + 1) {\n        resultIndex = bottomLimit;\n    }\n    if (currentResultIndex === bottomLimit - 1) {\n        resultIndex = topLimit;\n    }\n    return resultIndex;\n}\n/**\n * @param {?} response\n * @return {?}\n */\nfunction toJsonpSingleResult(response) {\n    return response[1];\n}\n/**\n * @param {?} results\n * @return {?}\n */\nfunction toJsonpFinalResults(results) {\n    return results.map(function (result) { return result[0]; });\n}\n/**\n * @param {?} query\n * @return {?}\n */\nfunction hasCharacters(query) {\n    return query.length > 0;\n}\n/**\n * @param {?} e\n * @return {?}\n */\nfunction toFormControlValue(e) {\n    return e.target.value;\n}\n/**\n * @param {?} item\n * @param {?} fieldsToExtract\n * @param {?=} caseSensitive\n * @return {?}\n */\nfunction resolveItemValue(item, fieldsToExtract, caseSensitive) {\n    if (caseSensitive === void 0) { caseSensitive = false; }\n    var /** @type {?} */ newItem = item;\n    if (!item.hasOwnProperty('length')) {\n        var /** @type {?} */ fields = !fieldsToExtract.length\n            ? Object.keys(item)\n            : fieldsToExtract;\n        newItem = fields.reduce(function (acc, cur) { return \"\" + acc + item[cur]; }, '');\n    }\n    return caseSensitive ? newItem : newItem.toLowerCase();\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar NgxTypeAheadComponent = /** @class */ (function () {\n    function NgxTypeAheadComponent(element, viewContainer, http$$1, cdr) {\n        this.element = element;\n        this.viewContainer = viewContainer;\n        this.http = http$$1;\n        this.cdr = cdr;\n        this.showSuggestions = false;\n        this.results = [];\n        this.taUrl = '';\n        this.taParams = {};\n        this.taQueryParam = 'q';\n        this.taApi = 'jsonp';\n        this.taApiMethod = 'get';\n        this.taList = [];\n        this.taListItemField = [];\n        this.taListItemLabel = '';\n        this.taDebounce = 300;\n        this.taAllowEmpty = false;\n        this.taCaseSensitive = false;\n        this.taDisplayOnFocus = false;\n        this.taSelected = new core.EventEmitter();\n        this.suggestionIndex = 0;\n        this.subscriptions = [];\n        this.activeResult = '';\n        this.searchQuery = '';\n        this.selectedItem = {};\n        this.resultsAsItems = [];\n        this.keydown$ = new Subject();\n        this.keyup$ = new Subject();\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.handleEsc = /**\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        if (isEscapeKey(event)) {\n            this.hideSuggestions();\n            event.preventDefault();\n        }\n        this.keydown$.next(event);\n    };\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.onkeyup = /**\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n        this.keyup$.next(event);\n    };\n    /**\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.onClick = /**\n     * @return {?}\n     */\n    function () {\n        if (this.taDisplayOnFocus) {\n            this.displaySuggestions();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.ngOnInit = /**\n     * @return {?}\n     */\n    function () {\n        this.filterEnterEvent(this.keydown$);\n        this.listenAndSuggest(this.keyup$);\n        this.navigateWithArrows(this.keydown$);\n        this.renderTemplate();\n    };\n    /**\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.keydown$.complete();\n        this.keyup$.complete();\n    };\n    /**\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.renderTemplate = /**\n     * @return {?}\n     */\n    function () {\n        this.viewContainer.createEmbeddedView(this.suggestionsTplRef);\n        this.cdr.markForCheck();\n    };\n    /**\n     * @param {?} obs\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.listenAndSuggest = /**\n     * @param {?} obs\n     * @return {?}\n     */\n    function (obs) {\n        var _this = this;\n        obs\n            .pipe(operators.filter(function (e) { return validateNonCharKeyCode(e.keyCode); }), operators.map(toFormControlValue), operators.debounceTime(this.taDebounce), operators.concat(), operators.distinctUntilChanged(), operators.filter(function (query) { return _this.taAllowEmpty || hasCharacters(query); }), operators.tap(function (query) { return (_this.searchQuery = query); }), operators.switchMap(function (query) { return _this.suggest(query); }))\n            .subscribe(function (results) {\n            _this.assignResults(results);\n            _this.updateIndex(Key.ArrowDown);\n            _this.displaySuggestions();\n        });\n    };\n    /**\n     * @param {?} results\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.assignResults = /**\n     * @param {?} results\n     * @return {?}\n     */\n    function (results) {\n        var /** @type {?} */ labelForDisplay = this.taListItemLabel;\n        this.resultsAsItems = results;\n        this.results = results.map(function (item) { return (labelForDisplay ? item[labelForDisplay] : item); });\n        this.suggestionIndex = -1;\n        if (!results || !results.length) {\n            this.activeResult = this.searchQuery;\n        }\n    };\n    /**\n     * @param {?} elementObs\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.filterEnterEvent = /**\n     * @param {?} elementObs\n     * @return {?}\n     */\n    function (elementObs) {\n        var _this = this;\n        elementObs.pipe(operators.filter(isEnterKey)).subscribe(function (event) {\n            _this.handleSelectSuggestion(_this.activeResult);\n        });\n    };\n    /**\n     * @param {?} elementObs\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.navigateWithArrows = /**\n     * @param {?} elementObs\n     * @return {?}\n     */\n    function (elementObs) {\n        var _this = this;\n        elementObs\n            .pipe(operators.filter(function (e) { return validateArrowKeys(e.keyCode); }), operators.map(function (e) { return e.keyCode; }))\n            .subscribe(function (keyCode) {\n            _this.updateIndex(keyCode);\n            _this.displaySuggestions();\n        });\n    };\n    /**\n     * @param {?} keyCode\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.updateIndex = /**\n     * @param {?} keyCode\n     * @return {?}\n     */\n    function (keyCode) {\n        this.suggestionIndex = resolveNextIndex(this.suggestionIndex, keyCode === Key.ArrowDown, this.results.length);\n    };\n    /**\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.displaySuggestions = /**\n     * @return {?}\n     */\n    function () {\n        this.showSuggestions = true;\n        this.cdr.markForCheck();\n    };\n    /**\n     * @param {?} query\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.suggest = /**\n     * @param {?} query\n     * @return {?}\n     */\n    function (query) {\n        return this.taList.length\n            ? this.createListSource(this.taList, query)\n            : this.request(query);\n    };\n    /**\n     * peforms a jsonp/http request to search with query and params\n     * @param query the query to search from the remote source\n     */\n    /**\n     * peforms a jsonp/http request to search with query and params\n     * @param {?} query the query to search from the remote source\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.request = /**\n     * peforms a jsonp/http request to search with query and params\n     * @param {?} query the query to search from the remote source\n     * @return {?}\n     */\n    function (query) {\n        var /** @type {?} */ url = this.taUrl;\n        var /** @type {?} */ searchConfig = createParamsForQuery(query, this.taQueryParam, this.taParams);\n        var /** @type {?} */ options = {\n            params: searchConfig\n        };\n        var /** @type {?} */ isJsonpApi = this.taApi === 'jsonp';\n        return isJsonpApi\n            ? this.requestJsonp(url, options, this.taCallbackParamValue)\n            : this.requestHttp(url, options);\n    };\n    /**\n     * @param {?} url\n     * @param {?} options\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.requestHttp = /**\n     * @param {?} url\n     * @param {?} options\n     * @return {?}\n     */\n    function (url, options) {\n        var /** @type {?} */ apiMethod = resolveApiMethod(this.taApiMethod);\n        return this.http[apiMethod](url, options);\n    };\n    /**\n     * @param {?} url\n     * @param {?} options\n     * @param {?=} callback\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.requestJsonp = /**\n     * @param {?} url\n     * @param {?} options\n     * @param {?=} callback\n     * @return {?}\n     */\n    function (url, options, callback) {\n        if (callback === void 0) { callback = 'callback'; }\n        var /** @type {?} */ params = options.params.toString();\n        return this.http.jsonp(url + \"?\" + params, callback).pipe(operators.map(toJsonpSingleResult), operators.map(toJsonpFinalResults));\n    };\n    /**\n     * @param {?} index\n     * @param {?} result\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.markIsActive = /**\n     * @param {?} index\n     * @param {?} result\n     * @return {?}\n     */\n    function (index, result) {\n        var /** @type {?} */ isActive = isIndexActive(index, this.suggestionIndex);\n        if (isActive) {\n            this.activeResult = result;\n        }\n        return isActive;\n    };\n    /**\n     * @param {?} suggestion\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.handleSelectSuggestion = /**\n     * @param {?} suggestion\n     * @return {?}\n     */\n    function (suggestion) {\n        var /** @type {?} */ result = this.resultsAsItems.length\n            ? this.resultsAsItems[this.suggestionIndex]\n            : suggestion;\n        this.hideSuggestions();\n        this.taSelected.emit(result);\n    };\n    /**\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.hideSuggestions = /**\n     * @return {?}\n     */\n    function () {\n        this.showSuggestions = false;\n    };\n    /**\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.hasItemTemplate = /**\n     * @return {?}\n     */\n    function () {\n        return this.taItemTpl !== undefined;\n    };\n    /**\n     * @param {?} list\n     * @param {?} query\n     * @return {?}\n     */\n    NgxTypeAheadComponent.prototype.createListSource = /**\n     * @param {?} list\n     * @param {?} query\n     * @return {?}\n     */\n    function (list, query) {\n        var _this = this;\n        var /** @type {?} */ sanitizedQuery = this.taCaseSensitive ? query : query.toLowerCase();\n        var /** @type {?} */ fieldsToExtract = this.taListItemField;\n        return of(list.filter(function (item) {\n            return resolveItemValue(item, fieldsToExtract, _this.taCaseSensitive).includes(sanitizedQuery);\n        }));\n    };\n    NgxTypeAheadComponent.decorators = [\n        { type: core.Component, args: [{\n                    selector: '[ngxTypeahead]',\n                    styles: [\n                        \"\\n      .ta-results {\\n        position: absolute;\\n      }\\n      .ta-backdrop {\\n        bottom: 0;\\n        left: 0;\\n        position: fixed;\\n        right: 0;\\n        top: 0;\\n        z-index: 1;\\n      }\\n      .ta-item {\\n        position: relative;\\n        z-index: 2;\\n        display: block;\\n      }\\n    \"\n                    ],\n                    template: \"\\n  <ng-template #suggestionsTplRef>\\n  <section class=\\\"ta-results list-group\\\" *ngIf=\\\"showSuggestions\\\">\\n    <div class=\\\"ta-backdrop\\\" (click)=\\\"hideSuggestions()\\\"></div>\\n    <button type=\\\"button\\\" class=\\\"ta-item list-group-item\\\"\\n      *ngFor=\\\"let result of results; let i = index;\\\"\\n      [class.active]=\\\"markIsActive(i, result)\\\"\\n      (click)=\\\"handleSelectSuggestion(result)\\\">\\n      <span *ngIf=\\\"!taItemTpl\\\"><i class=\\\"fa fa-search\\\"></i> {{ result }}</span>\\n      <ng-template\\n        [ngTemplateOutlet]=\\\"taItemTpl\\\"\\n        [ngTemplateOutletContext]=\\\"{ $implicit: {result: result, index: i} }\\\"\\n      ></ng-template>\\n    </button>\\n  </section>\\n  </ng-template>\\n  \"\n                },] },\n    ];\n    /** @nocollapse */\n    NgxTypeAheadComponent.ctorParameters = function () { return [\n        { type: core.ElementRef, },\n        { type: core.ViewContainerRef, },\n        { type: http.HttpClient, },\n        { type: core.ChangeDetectorRef, },\n    ]; };\n    NgxTypeAheadComponent.propDecorators = {\n        \"taItemTpl\": [{ type: core.Input },],\n        \"taUrl\": [{ type: core.Input },],\n        \"taParams\": [{ type: core.Input },],\n        \"taQueryParam\": [{ type: core.Input },],\n        \"taCallbackParamValue\": [{ type: core.Input },],\n        \"taApi\": [{ type: core.Input },],\n        \"taApiMethod\": [{ type: core.Input },],\n        \"taList\": [{ type: core.Input },],\n        \"taListItemField\": [{ type: core.Input },],\n        \"taListItemLabel\": [{ type: core.Input },],\n        \"taDebounce\": [{ type: core.Input },],\n        \"taAllowEmpty\": [{ type: core.Input },],\n        \"taCaseSensitive\": [{ type: core.Input },],\n        \"taDisplayOnFocus\": [{ type: core.Input },],\n        \"taSelected\": [{ type: core.Output },],\n        \"suggestionsTplRef\": [{ type: core.ViewChild, args: ['suggestionsTplRef',] },],\n        \"handleEsc\": [{ type: core.HostListener, args: ['keydown', ['$event'],] },],\n        \"onkeyup\": [{ type: core.HostListener, args: ['keyup', ['$event'],] },],\n        \"onClick\": [{ type: core.HostListener, args: ['click',] },],\n    };\n    return NgxTypeAheadComponent;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar NgxTypeaheadModule = /** @class */ (function () {\n    function NgxTypeaheadModule() {\n    }\n    NgxTypeaheadModule.decorators = [\n        { type: core.NgModule, args: [{\n                    declarations: [NgxTypeAheadComponent],\n                    exports: [NgxTypeAheadComponent, common.CommonModule],\n                    imports: [common.CommonModule, http.HttpClientModule, http.HttpClientJsonpModule],\n                    providers: []\n                },] },\n    ];\n    return NgxTypeaheadModule;\n}());\n\nexports.NgxTypeaheadModule = NgxTypeaheadModule;\nexports.Éµa = NgxTypeAheadComponent;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=ngx-typeahead.umd.js.map\n"]}
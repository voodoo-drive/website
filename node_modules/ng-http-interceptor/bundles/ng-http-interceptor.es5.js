import * as tslib_1 from "tslib";
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/empty';
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/mergeMap';
import { Injectable, NgModule } from '@angular/core';
import { ConnectionBackend, Headers, Http, HttpModule, RequestOptions, XHRBackend } from '@angular/http';
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var InterceptableStoreFactory = (function () {
    function InterceptableStoreFactory() {
    }
    /**
     * @template D
     * @return {?}
     */
    InterceptableStoreFactory.prototype.createStore = function () {
        return new InterceptableStore();
    };
    return InterceptableStoreFactory;
}());
InterceptableStoreFactory.decorators = [
    { type: Injectable },
];
/** @nocollapse */
InterceptableStoreFactory.ctorParameters = function () { return []; };
var DEFAULT_URL_STORE = '/';
var InterceptableStore = (function () {
    function InterceptableStore() {
        this.storeMatcher = {};
        this.stores = {};
        this.activeStore = DEFAULT_URL_STORE;
    }
    Object.defineProperty(InterceptableStore.prototype, "store", {
        /**
         * @return {?}
         */
        get: function () {
            return this._getStoreSafely(this.activeStore);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} interceptor
     * @return {?}
     */
    InterceptableStore.prototype.addInterceptor = function (interceptor) {
        this.store.push(interceptor);
        return this;
    };
    /**
     * @param {?} interceptor
     * @return {?}
     */
    InterceptableStore.prototype.removeInterceptor = function (interceptor) {
        var /** @type {?} */ idx = this.store.indexOf(interceptor);
        if (idx === -1) {
            return this;
        }
        this.store.splice(idx, 1);
        return this;
    };
    /**
     * @param {?=} interceptors
     * @return {?}
     */
    InterceptableStore.prototype.clearInterceptors = function (interceptors) {
        var _this = this;
        if (interceptors === void 0) { interceptors = []; }
        if (interceptors.length > 0) {
            interceptors.forEach(function (i) { return _this.removeInterceptor(i); });
        }
        else {
            this.store.splice(0);
        }
        return this;
    };
    /**
     * @param {?=} url
     * @return {?}
     */
    InterceptableStore.prototype.setActiveStore = function (url) {
        if (url === void 0) { url = DEFAULT_URL_STORE; }
        this.activeStore = String(url);
        if (url instanceof RegExp) {
            this.storeMatcher[this.activeStore] = url;
        }
        return this;
    };
    /**
     * @param {?=} key
     * @return {?}
     */
    InterceptableStore.prototype.getStore = function (key) {
        if (key === void 0) { key = DEFAULT_URL_STORE; }
        return this._getStoreSafely(key);
    };
    /**
     * @param {?=} url
     * @return {?}
     */
    InterceptableStore.prototype.getMatchedStores = function (url) {
        var _this = this;
        if (url === void 0) { url = DEFAULT_URL_STORE; }
        var /** @type {?} */ backedUrl = "/" + url.replace('/', '\\/') + "/"; // Use it for direct string matching
        return Object.keys(this.stores)
            .filter(function (k) { return k === url || k === backedUrl || (_this.storeMatcher[k] && _this.storeMatcher[k].test(url)); })
            .filter(function (k, i, arr) { return k !== DEFAULT_URL_STORE && arr.indexOf(k) === i; })
            .map(function (k) { return _this.getStore(k); })
            .reduce(function (stores, store) { return stores.concat(store); }, this.getStore(DEFAULT_URL_STORE));
    };
    /**
     * @param {?} key
     * @return {?}
     */
    InterceptableStore.prototype._getStoreSafely = function (key) {
        return (this.stores[key] || (this.stores[key] = []));
    };
    return InterceptableStore;
}());
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var HttpInterceptorService = (function () {
    /**
     * @param {?} store
     */
    function HttpInterceptorService(store) {
        this.store = store;
        this._requestStore = this.store.createStore();
        this._responseStore = this.store.createStore();
    }
    /**
     * @param {?} res
     * @return {?}
     */
    HttpInterceptorService.wrapInObservable = function (res) {
        return res instanceof Observable ? res : Observable.of(res);
    };
    /**
     * @param {?=} url
     * @return {?}
     */
    HttpInterceptorService.prototype.request = function (url) {
        if (url === void 0) { url = DEFAULT_URL_STORE; }
        return this._requestStore.setActiveStore(url);
    };
    /**
     * @param {?=} url
     * @return {?}
     */
    HttpInterceptorService.prototype.response = function (url) {
        if (url === void 0) { url = DEFAULT_URL_STORE; }
        return this._responseStore.setActiveStore(url);
    };
    /**
     * @param {?} url
     * @param {?} method
     * @param {?} data
     * @param {?=} context
     * @return {?}
     */
    HttpInterceptorService.prototype._interceptRequest = function (url, method, data, context) {
        return this._requestStore.getMatchedStores(url).reduce(function (o, i) { return o.flatMap(function (d) {
            if (!d) {
                return Observable.of(d);
            }
            return HttpInterceptorService.wrapInObservable(i(d, method, context));
        }); }, Observable.of(data));
    };
    /**
     * @param {?} url
     * @param {?} method
     * @param {?} response
     * @param {?=} context
     * @return {?}
     */
    HttpInterceptorService.prototype._interceptResponse = function (url, method, response, context) {
        return this._responseStore.getMatchedStores(url).reduce(function (o, i) { return i(o, method, context); }, response);
    };
    return HttpInterceptorService;
}());
HttpInterceptorService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
HttpInterceptorService.ctorParameters = function () { return [
    { type: InterceptableStoreFactory, },
]; };
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SAFE_PROXY_TRAPS = ['get', 'set', 'apply'];
/**
 * @param {?} ref
 * @return {?}
 */
function identityFactory_(ref) {
    return ref;
}
/**
 * @param {?} provide
 * @param {?} obj
 * @return {?}
 */
function identityFactory(provide, obj) {
    return {
        provide: provide,
        useFactory: identityFactory_,
        deps: [obj]
    };
}
/**
 * @param {?} handler
 * @return {?}
 */
function safeProxyHandler_(handler) {
    var /** @type {?} */ safeHandler = {};
    SAFE_PROXY_TRAPS
        .filter(function (trap) { return typeof handler[trap] === 'function'; })
        .forEach(function (trap) { return safeHandler[trap] = handler[trap].bind(handler); });
    return safeHandler;
}
/**
 * @param {?} obj
 * @param {?} handler
 * @return {?}
 */
function safeProxy(obj, handler) {
    return new Proxy(obj, safeProxyHandler_(handler));
}
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var InterceptableHttpProxyService = (function () {
    /**
     * @param {?} http
     * @param {?} httpInterceptorService
     */
    function InterceptableHttpProxyService(http, httpInterceptorService) {
        this.http = http;
        this.httpInterceptorService = httpInterceptorService;
    }
    /**
     * @param {?} url
     * @return {?}
     */
    InterceptableHttpProxyService._extractUrl = function (url) {
        var /** @type {?} */ dirtyUrl = url[0];
        return typeof dirtyUrl === 'object' && 'url' in dirtyUrl ? dirtyUrl.url : dirtyUrl;
    };
    /**
     * @param {?} target
     * @param {?} p
     * @param {?} receiver
     * @return {?}
     */
    InterceptableHttpProxyService.prototype.get = function (target, p, receiver) {
        InterceptableHttpProxyService._callStack.push(/** @type {?} */ (p));
        return receiver;
    };
    /**
     * @param {?} target
     * @param {?} thisArg
     * @param {?=} argArray
     * @return {?}
     */
    InterceptableHttpProxyService.prototype.apply = function (target, thisArg, argArray) {
        var _this = this;
        var /** @type {?} */ method = InterceptableHttpProxyService._callStack.pop();
        // Comply with strict null checks
        if (!method) {
            return Observable.empty();
        }
        // create a object without prototype as the context object
        var /** @type {?} */ context = Object.create(null);
        return this.httpInterceptorService
            ._interceptRequest(InterceptableHttpProxyService._extractUrl(argArray), method, argArray, context)
            .switchMap(function (args) {
            // Check for request cancellation
            if (!args) {
                return Observable.empty();
            }
            var /** @type {?} */ response = _this.http[method].apply(_this.http, args);
            return _this.httpInterceptorService._interceptResponse(InterceptableHttpProxyService._extractUrl(args), method, response, context);
        });
    };
    return InterceptableHttpProxyService;
}());
InterceptableHttpProxyService._callStack = [];
InterceptableHttpProxyService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
InterceptableHttpProxyService.ctorParameters = function () { return [
    { type: Http, },
    { type: HttpInterceptorService, },
]; };
var _proxyTarget = function () { return null; };
// Make sure all Http methods are known for Proxy Polyfill
Object.keys(Http.prototype).forEach(function (method) { return _proxyTarget[method] = "Http." + method; });
/**
 * @param {?} http
 * @param {?} interceptor
 * @return {?}
 */
function _proxyFactory(http, interceptor) {
    return safeProxy(_proxyTarget, new InterceptableHttpProxyService(http, interceptor));
}
/**
 * @param {?} backend
 * @param {?} options
 * @param {?} interceptor
 * @return {?}
 */
function proxyFactory(backend, options, interceptor) {
    return _proxyFactory(new Http(backend, options), interceptor);
}
var InterceptableHttpProxyProviders = [
    {
        provide: Http,
        useFactory: proxyFactory,
        deps: [XHRBackend, RequestOptions, HttpInterceptorService]
    },
    identityFactory(InterceptableHttpProxyService, Http),
];
var InterceptableHttpProxyNoOverrideProviders = [
    {
        provide: InterceptableHttpProxyService,
        useFactory: _proxyFactory,
        deps: [Http, HttpInterceptorService]
    }
];
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var InterceptableHttp = (function (_super) {
    tslib_1.__extends(InterceptableHttp, _super);
    /**
     * @param {?} _backend
     * @param {?} _defaultOptions
     */
    function InterceptableHttp(_backend, _defaultOptions) {
        return _super.call(this, _backend, _defaultOptions) || this;
    }
    return InterceptableHttp;
}(Http));
InterceptableHttp.decorators = [
    { type: Injectable },
];
/** @nocollapse */
InterceptableHttp.ctorParameters = function () { return [
    { type: ConnectionBackend, },
    { type: RequestOptions, },
]; };
var InterceptableHttpProviders = [
    identityFactory(InterceptableHttp, InterceptableHttpProxyService)
];
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SharedProviders = [
    InterceptableStoreFactory,
    HttpInterceptorService
].concat(InterceptableHttpProviders);
var HTTP_INTERCEPTOR_PROVIDER = SharedProviders.concat(InterceptableHttpProxyProviders);
var HTTP_INTERCEPTOR_NO_OVERRIDE_PROVIDER = SharedProviders.concat(InterceptableHttpProxyNoOverrideProviders);
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@module
 * \@description
 * Library provides Http Interceptor Service for Angular 2 application
 * By default overrides angular's Http service
 * To keep original Http service use with {\@see HttpInterceptorModule.noOverrideHttp()}
 */
var HttpInterceptorModule = (function () {
    function HttpInterceptorModule() {
    }
    /**
     * Keeps original Http service and adds InterceptableHttp service
     * Requests made by Http service will not be intercepted - only those made by InterceptableHttp
     * @return {?}
     */
    HttpInterceptorModule.noOverrideHttp = function () {
        return {
            ngModule: HttpInterceptorNoOverrideModule
        };
    };
    return HttpInterceptorModule;
}());
HttpInterceptorModule.decorators = [
    { type: NgModule, args: [{
                imports: [HttpModule],
                providers: [HTTP_INTERCEPTOR_PROVIDER]
            },] },
];
/** @nocollapse */
HttpInterceptorModule.ctorParameters = function () { return []; };
var HttpInterceptorNoOverrideModule = (function () {
    function HttpInterceptorNoOverrideModule() {
    }
    return HttpInterceptorNoOverrideModule;
}());
HttpInterceptorNoOverrideModule.decorators = [
    { type: NgModule, args: [{
                imports: [HttpModule],
                providers: [HTTP_INTERCEPTOR_NO_OVERRIDE_PROVIDER]
            },] },
];
/** @nocollapse */
HttpInterceptorNoOverrideModule.ctorParameters = function () { return []; };
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@description
 * Gets index of {\@link RequestOptions} in http data array for specified `method`.
 * @param {?} method - Http method
 * @return {?}
 */
function getHttpOptionsIdx(method) {
    switch (method) {
        case 'post':
        case 'put':
        case 'patch':
            return 2;
        default:
            return 1;
    }
}
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@description
 * Gets http {\@link RequestOptions} from data array.
 * If no options found and `alwaysOriginal = false` - returns new {\@link RequestOptions}.
 * @param {?} data - Array of http data
 * @param {?} method - Http method
 * @param {?=} alwaysOriginal - `false` by default
 * @return {?}
 */
function getHttpOptions(data, method, alwaysOriginal) {
    if (alwaysOriginal === void 0) { alwaysOriginal = false; }
    return alwaysOriginal ?
        data[getHttpOptionsIdx(method)] :
        data[getHttpOptionsIdx(method)] || new RequestOptions();
}
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@description
 * Gets {\@link RequestOptions} and it's index location in data array.
 * If no options found and `alwaysOriginal = false` - creates new {\@link RequestOptions}.
 * @param {?} data - Array of http data
 * @param {?} method - Http method
 * @param {?=} alwaysOriginal - `false` by default
 * @return {?}
 */
function getHttpOptionsAndIdx(data, method, alwaysOriginal) {
    if (alwaysOriginal === void 0) { alwaysOriginal = false; }
    return {
        options: /** @type {?} */ (getHttpOptions(data, method, alwaysOriginal)),
        idx: getHttpOptionsIdx(method)
    };
}
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@description
 * Gets {\@link Headers} from data array.
 * If no {\@link RequestOptions} found - creates it and updates original data array.
 * If no {\@link Headers} found - creates it and sets to {\@link RequestOptions}.
 * @param {?} data - Array of http data
 * @param {?} method - Http method
 * @return {?}
 */
function getHttpHeadersOrInit(data, method) {
    var _a = getHttpOptionsAndIdx(data, method), options = _a.options, idx = _a.idx;
    var /** @type {?} */ headers = options.headers;
    // Create and update Headers
    if (!options.headers) {
        headers = new Headers();
        options.headers = headers;
    }
    // Set Options back
    data[idx] = options;
    return headers;
}
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @module
 * @description
 * Library provides Http Interceptor Service for Angular 2 application
 * By default overrides angular's Http service
 * To keep original Http service use with {@see HttpInterceptorModule.noOverrideHttp()}
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */
export { HttpInterceptorModule, HttpInterceptorNoOverrideModule, InterceptableHttp, InterceptableHttpProviders, HttpInterceptorService, getHttpOptions, getHttpOptionsIdx, getHttpOptionsAndIdx, getHttpHeadersOrInit, InterceptableHttpProxyNoOverrideProviders as ɵm, InterceptableHttpProxyProviders as ɵl, InterceptableHttpProxyService as ɵh, _proxyFactory as ɵj, _proxyTarget as ɵi, proxyFactory as ɵk, InterceptableStoreFactory as ɵc, HTTP_INTERCEPTOR_NO_OVERRIDE_PROVIDER as ɵb, HTTP_INTERCEPTOR_PROVIDER as ɵa, identityFactory as ɵe, identityFactory_ as ɵd, safeProxy as ɵg, safeProxyHandler_ as ɵf };

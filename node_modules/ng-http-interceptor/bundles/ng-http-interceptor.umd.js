(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs/Observable'), require('rxjs/add/observable/of'), require('rxjs/add/observable/empty'), require('rxjs/add/operator/switchMap'), require('rxjs/add/operator/mergeMap'), require('@angular/core'), require('@angular/http')) :
	typeof define === 'function' && define.amd ? define(['exports', 'rxjs/Observable', 'rxjs/add/observable/of', 'rxjs/add/observable/empty', 'rxjs/add/operator/switchMap', 'rxjs/add/operator/mergeMap', '@angular/core', '@angular/http'], factory) :
	(factory((global.httpInterceptor = global.httpInterceptor || {}),global.Rx,global.Rx.Observable,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.ng.core,global.ng.http));
}(this, (function (exports,rxjs_Observable,rxjs_add_observable_of,rxjs_add_observable_empty,rxjs_add_operator_switchMap,rxjs_add_operator_mergeMap,_angular_core,_angular_http) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var InterceptableStoreFactory = (function () {
    function InterceptableStoreFactory() {
    }
    /**
     * @template D
     * @return {?}
     */
    InterceptableStoreFactory.prototype.createStore = function () {
        return new InterceptableStore();
    };
    return InterceptableStoreFactory;
}());
InterceptableStoreFactory.decorators = [
    { type: _angular_core.Injectable },
];
/** @nocollapse */
InterceptableStoreFactory.ctorParameters = function () { return []; };
var DEFAULT_URL_STORE = '/';
var InterceptableStore = (function () {
    function InterceptableStore() {
        this.storeMatcher = {};
        this.stores = {};
        this.activeStore = DEFAULT_URL_STORE;
    }
    Object.defineProperty(InterceptableStore.prototype, "store", {
        /**
         * @return {?}
         */
        get: function () {
            return this._getStoreSafely(this.activeStore);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} interceptor
     * @return {?}
     */
    InterceptableStore.prototype.addInterceptor = function (interceptor) {
        this.store.push(interceptor);
        return this;
    };
    /**
     * @param {?} interceptor
     * @return {?}
     */
    InterceptableStore.prototype.removeInterceptor = function (interceptor) {
        var /** @type {?} */ idx = this.store.indexOf(interceptor);
        if (idx === -1) {
            return this;
        }
        this.store.splice(idx, 1);
        return this;
    };
    /**
     * @param {?=} interceptors
     * @return {?}
     */
    InterceptableStore.prototype.clearInterceptors = function (interceptors) {
        var _this = this;
        if (interceptors === void 0) { interceptors = []; }
        if (interceptors.length > 0) {
            interceptors.forEach(function (i) { return _this.removeInterceptor(i); });
        }
        else {
            this.store.splice(0);
        }
        return this;
    };
    /**
     * @param {?=} url
     * @return {?}
     */
    InterceptableStore.prototype.setActiveStore = function (url) {
        if (url === void 0) { url = DEFAULT_URL_STORE; }
        this.activeStore = String(url);
        if (url instanceof RegExp) {
            this.storeMatcher[this.activeStore] = url;
        }
        return this;
    };
    /**
     * @param {?=} key
     * @return {?}
     */
    InterceptableStore.prototype.getStore = function (key) {
        if (key === void 0) { key = DEFAULT_URL_STORE; }
        return this._getStoreSafely(key);
    };
    /**
     * @param {?=} url
     * @return {?}
     */
    InterceptableStore.prototype.getMatchedStores = function (url) {
        var _this = this;
        if (url === void 0) { url = DEFAULT_URL_STORE; }
        var /** @type {?} */ backedUrl = "/" + url.replace('/', '\\/') + "/"; // Use it for direct string matching
        return Object.keys(this.stores)
            .filter(function (k) { return k === url || k === backedUrl || (_this.storeMatcher[k] && _this.storeMatcher[k].test(url)); })
            .filter(function (k, i, arr) { return k !== DEFAULT_URL_STORE && arr.indexOf(k) === i; })
            .map(function (k) { return _this.getStore(k); })
            .reduce(function (stores, store) { return stores.concat(store); }, this.getStore(DEFAULT_URL_STORE));
    };
    /**
     * @param {?} key
     * @return {?}
     */
    InterceptableStore.prototype._getStoreSafely = function (key) {
        return (this.stores[key] || (this.stores[key] = []));
    };
    return InterceptableStore;
}());
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var HttpInterceptorService = (function () {
    /**
     * @param {?} store
     */
    function HttpInterceptorService(store) {
        this.store = store;
        this._requestStore = this.store.createStore();
        this._responseStore = this.store.createStore();
    }
    /**
     * @param {?} res
     * @return {?}
     */
    HttpInterceptorService.wrapInObservable = function (res) {
        return res instanceof rxjs_Observable.Observable ? res : rxjs_Observable.Observable.of(res);
    };
    /**
     * @param {?=} url
     * @return {?}
     */
    HttpInterceptorService.prototype.request = function (url) {
        if (url === void 0) { url = DEFAULT_URL_STORE; }
        return this._requestStore.setActiveStore(url);
    };
    /**
     * @param {?=} url
     * @return {?}
     */
    HttpInterceptorService.prototype.response = function (url) {
        if (url === void 0) { url = DEFAULT_URL_STORE; }
        return this._responseStore.setActiveStore(url);
    };
    /**
     * @param {?} url
     * @param {?} method
     * @param {?} data
     * @param {?=} context
     * @return {?}
     */
    HttpInterceptorService.prototype._interceptRequest = function (url, method, data, context) {
        return this._requestStore.getMatchedStores(url).reduce(function (o, i) { return o.flatMap(function (d) {
            if (!d) {
                return rxjs_Observable.Observable.of(d);
            }
            return HttpInterceptorService.wrapInObservable(i(d, method, context));
        }); }, rxjs_Observable.Observable.of(data));
    };
    /**
     * @param {?} url
     * @param {?} method
     * @param {?} response
     * @param {?=} context
     * @return {?}
     */
    HttpInterceptorService.prototype._interceptResponse = function (url, method, response, context) {
        return this._responseStore.getMatchedStores(url).reduce(function (o, i) { return i(o, method, context); }, response);
    };
    return HttpInterceptorService;
}());
HttpInterceptorService.decorators = [
    { type: _angular_core.Injectable },
];
/** @nocollapse */
HttpInterceptorService.ctorParameters = function () { return [
    { type: InterceptableStoreFactory, },
]; };
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SAFE_PROXY_TRAPS = ['get', 'set', 'apply'];
/**
 * @param {?} ref
 * @return {?}
 */
function identityFactory_(ref) {
    return ref;
}
/**
 * @param {?} provide
 * @param {?} obj
 * @return {?}
 */
function identityFactory(provide, obj) {
    return {
        provide: provide,
        useFactory: identityFactory_,
        deps: [obj]
    };
}
/**
 * @param {?} handler
 * @return {?}
 */
function safeProxyHandler_(handler) {
    var /** @type {?} */ safeHandler = {};
    SAFE_PROXY_TRAPS
        .filter(function (trap) { return typeof handler[trap] === 'function'; })
        .forEach(function (trap) { return safeHandler[trap] = handler[trap].bind(handler); });
    return safeHandler;
}
/**
 * @param {?} obj
 * @param {?} handler
 * @return {?}
 */
function safeProxy(obj, handler) {
    return new Proxy(obj, safeProxyHandler_(handler));
}
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var InterceptableHttpProxyService = (function () {
    /**
     * @param {?} http
     * @param {?} httpInterceptorService
     */
    function InterceptableHttpProxyService(http, httpInterceptorService) {
        this.http = http;
        this.httpInterceptorService = httpInterceptorService;
    }
    /**
     * @param {?} url
     * @return {?}
     */
    InterceptableHttpProxyService._extractUrl = function (url) {
        var /** @type {?} */ dirtyUrl = url[0];
        return typeof dirtyUrl === 'object' && 'url' in dirtyUrl ? dirtyUrl.url : dirtyUrl;
    };
    /**
     * @param {?} target
     * @param {?} p
     * @param {?} receiver
     * @return {?}
     */
    InterceptableHttpProxyService.prototype.get = function (target, p, receiver) {
        InterceptableHttpProxyService._callStack.push(/** @type {?} */ (p));
        return receiver;
    };
    /**
     * @param {?} target
     * @param {?} thisArg
     * @param {?=} argArray
     * @return {?}
     */
    InterceptableHttpProxyService.prototype.apply = function (target, thisArg, argArray) {
        var _this = this;
        var /** @type {?} */ method = InterceptableHttpProxyService._callStack.pop();
        // Comply with strict null checks
        if (!method) {
            return rxjs_Observable.Observable.empty();
        }
        // create a object without prototype as the context object
        var /** @type {?} */ context = Object.create(null);
        return this.httpInterceptorService
            ._interceptRequest(InterceptableHttpProxyService._extractUrl(argArray), method, argArray, context)
            .switchMap(function (args) {
            // Check for request cancellation
            if (!args) {
                return rxjs_Observable.Observable.empty();
            }
            var /** @type {?} */ response = _this.http[method].apply(_this.http, args);
            return _this.httpInterceptorService._interceptResponse(InterceptableHttpProxyService._extractUrl(args), method, response, context);
        });
    };
    return InterceptableHttpProxyService;
}());
InterceptableHttpProxyService._callStack = [];
InterceptableHttpProxyService.decorators = [
    { type: _angular_core.Injectable },
];
/** @nocollapse */
InterceptableHttpProxyService.ctorParameters = function () { return [
    { type: _angular_http.Http, },
    { type: HttpInterceptorService, },
]; };
var _proxyTarget = function () { return null; };
// Make sure all Http methods are known for Proxy Polyfill
Object.keys(_angular_http.Http.prototype).forEach(function (method) { return _proxyTarget[method] = "Http." + method; });
/**
 * @param {?} http
 * @param {?} interceptor
 * @return {?}
 */
function _proxyFactory(http, interceptor) {
    return safeProxy(_proxyTarget, new InterceptableHttpProxyService(http, interceptor));
}
/**
 * @param {?} backend
 * @param {?} options
 * @param {?} interceptor
 * @return {?}
 */
function proxyFactory(backend, options, interceptor) {
    return _proxyFactory(new _angular_http.Http(backend, options), interceptor);
}
var InterceptableHttpProxyProviders = [
    {
        provide: _angular_http.Http,
        useFactory: proxyFactory,
        deps: [_angular_http.XHRBackend, _angular_http.RequestOptions, HttpInterceptorService]
    },
    identityFactory(InterceptableHttpProxyService, _angular_http.Http),
];
var InterceptableHttpProxyNoOverrideProviders = [
    {
        provide: InterceptableHttpProxyService,
        useFactory: _proxyFactory,
        deps: [_angular_http.Http, HttpInterceptorService]
    }
];
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var InterceptableHttp = (function (_super) {
    __extends(InterceptableHttp, _super);
    /**
     * @param {?} _backend
     * @param {?} _defaultOptions
     */
    function InterceptableHttp(_backend, _defaultOptions) {
        return _super.call(this, _backend, _defaultOptions) || this;
    }
    return InterceptableHttp;
}(_angular_http.Http));
InterceptableHttp.decorators = [
    { type: _angular_core.Injectable },
];
/** @nocollapse */
InterceptableHttp.ctorParameters = function () { return [
    { type: _angular_http.ConnectionBackend, },
    { type: _angular_http.RequestOptions, },
]; };
var InterceptableHttpProviders = [
    identityFactory(InterceptableHttp, InterceptableHttpProxyService)
];
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SharedProviders = [
    InterceptableStoreFactory,
    HttpInterceptorService
].concat(InterceptableHttpProviders);
var HTTP_INTERCEPTOR_PROVIDER = SharedProviders.concat(InterceptableHttpProxyProviders);
var HTTP_INTERCEPTOR_NO_OVERRIDE_PROVIDER = SharedProviders.concat(InterceptableHttpProxyNoOverrideProviders);
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@module
 * \@description
 * Library provides Http Interceptor Service for Angular 2 application
 * By default overrides angular's Http service
 * To keep original Http service use with {\@see HttpInterceptorModule.noOverrideHttp()}
 */
var HttpInterceptorModule = (function () {
    function HttpInterceptorModule() {
    }
    /**
     * Keeps original Http service and adds InterceptableHttp service
     * Requests made by Http service will not be intercepted - only those made by InterceptableHttp
     * @return {?}
     */
    HttpInterceptorModule.noOverrideHttp = function () {
        return {
            ngModule: HttpInterceptorNoOverrideModule
        };
    };
    return HttpInterceptorModule;
}());
HttpInterceptorModule.decorators = [
    { type: _angular_core.NgModule, args: [{
                imports: [_angular_http.HttpModule],
                providers: [HTTP_INTERCEPTOR_PROVIDER]
            },] },
];
/** @nocollapse */
HttpInterceptorModule.ctorParameters = function () { return []; };
var HttpInterceptorNoOverrideModule = (function () {
    function HttpInterceptorNoOverrideModule() {
    }
    return HttpInterceptorNoOverrideModule;
}());
HttpInterceptorNoOverrideModule.decorators = [
    { type: _angular_core.NgModule, args: [{
                imports: [_angular_http.HttpModule],
                providers: [HTTP_INTERCEPTOR_NO_OVERRIDE_PROVIDER]
            },] },
];
/** @nocollapse */
HttpInterceptorNoOverrideModule.ctorParameters = function () { return []; };
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@description
 * Gets index of {\@link RequestOptions} in http data array for specified `method`.
 * @param {?} method - Http method
 * @return {?}
 */
function getHttpOptionsIdx(method) {
    switch (method) {
        case 'post':
        case 'put':
        case 'patch':
            return 2;
        default:
            return 1;
    }
}
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@description
 * Gets http {\@link RequestOptions} from data array.
 * If no options found and `alwaysOriginal = false` - returns new {\@link RequestOptions}.
 * @param {?} data - Array of http data
 * @param {?} method - Http method
 * @param {?=} alwaysOriginal - `false` by default
 * @return {?}
 */
function getHttpOptions(data, method, alwaysOriginal) {
    if (alwaysOriginal === void 0) { alwaysOriginal = false; }
    return alwaysOriginal ?
        data[getHttpOptionsIdx(method)] :
        data[getHttpOptionsIdx(method)] || new _angular_http.RequestOptions();
}
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@description
 * Gets {\@link RequestOptions} and it's index location in data array.
 * If no options found and `alwaysOriginal = false` - creates new {\@link RequestOptions}.
 * @param {?} data - Array of http data
 * @param {?} method - Http method
 * @param {?=} alwaysOriginal - `false` by default
 * @return {?}
 */
function getHttpOptionsAndIdx(data, method, alwaysOriginal) {
    if (alwaysOriginal === void 0) { alwaysOriginal = false; }
    return {
        options: /** @type {?} */ (getHttpOptions(data, method, alwaysOriginal)),
        idx: getHttpOptionsIdx(method)
    };
}
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * \@description
 * Gets {\@link Headers} from data array.
 * If no {\@link RequestOptions} found - creates it and updates original data array.
 * If no {\@link Headers} found - creates it and sets to {\@link RequestOptions}.
 * @param {?} data - Array of http data
 * @param {?} method - Http method
 * @return {?}
 */
function getHttpHeadersOrInit(data, method) {
    var _a = getHttpOptionsAndIdx(data, method), options = _a.options, idx = _a.idx;
    var /** @type {?} */ headers = options.headers;
    // Create and update Headers
    if (!options.headers) {
        headers = new _angular_http.Headers();
        options.headers = headers;
    }
    // Set Options back
    data[idx] = options;
    return headers;
}

exports.HttpInterceptorModule = HttpInterceptorModule;
exports.HttpInterceptorNoOverrideModule = HttpInterceptorNoOverrideModule;
exports.InterceptableHttp = InterceptableHttp;
exports.InterceptableHttpProviders = InterceptableHttpProviders;
exports.HttpInterceptorService = HttpInterceptorService;
exports.getHttpOptions = getHttpOptions;
exports.getHttpOptionsIdx = getHttpOptionsIdx;
exports.getHttpOptionsAndIdx = getHttpOptionsAndIdx;
exports.getHttpHeadersOrInit = getHttpHeadersOrInit;
exports.ɵm = InterceptableHttpProxyNoOverrideProviders;
exports.ɵl = InterceptableHttpProxyProviders;
exports.ɵh = InterceptableHttpProxyService;
exports.ɵj = _proxyFactory;
exports.ɵi = _proxyTarget;
exports.ɵk = proxyFactory;
exports.ɵc = InterceptableStoreFactory;
exports.ɵb = HTTP_INTERCEPTOR_NO_OVERRIDE_PROVIDER;
exports.ɵa = HTTP_INTERCEPTOR_PROVIDER;
exports.ɵe = identityFactory;
exports.ɵd = identityFactory_;
exports.ɵg = safeProxy;
exports.ɵf = safeProxyHandler_;

Object.defineProperty(exports, '__esModule', { value: true });

})));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Injectable } from "@angular/core";
import { Http, XHRBackend, RequestOptions } from "@angular/http";
import { Observable } from "rxjs/Observable";
import { HttpInterceptorService } from "./http-interceptor.service";
import { identityFactory, safeProxy } from "./util";
export class InterceptableHttpProxyService {
    /**
     * @param {?} http
     * @param {?} httpInterceptorService
     */
    constructor(http, httpInterceptorService) {
        this.http = http;
        this.httpInterceptorService = httpInterceptorService;
    }
    /**
     * @param {?} url
     * @return {?}
     */
    static _extractUrl(url) {
        const /** @type {?} */ dirtyUrl = url[0];
        return typeof dirtyUrl === 'object' && 'url' in dirtyUrl ? dirtyUrl.url : dirtyUrl;
    }
    /**
     * @param {?} target
     * @param {?} p
     * @param {?} receiver
     * @return {?}
     */
    get(target, p, receiver) {
        InterceptableHttpProxyService._callStack.push(/** @type {?} */ (p));
        return receiver;
    }
    /**
     * @param {?} target
     * @param {?} thisArg
     * @param {?=} argArray
     * @return {?}
     */
    apply(target, thisArg, argArray) {
        const /** @type {?} */ method = InterceptableHttpProxyService._callStack.pop();
        // Comply with strict null checks
        if (!method) {
            return Observable.empty();
        }
        // create a object without prototype as the context object
        const /** @type {?} */ context = Object.create(null);
        return this.httpInterceptorService
            ._interceptRequest(InterceptableHttpProxyService._extractUrl(argArray), method, argArray, context)
            .switchMap(args => {
            // Check for request cancellation
            if (!args) {
                return Observable.empty();
            }
            const /** @type {?} */ response = this.http[method].apply(this.http, args);
            return this.httpInterceptorService._interceptResponse(InterceptableHttpProxyService._extractUrl(args), method, response, context);
        });
    }
}
InterceptableHttpProxyService._callStack = [];
InterceptableHttpProxyService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
InterceptableHttpProxyService.ctorParameters = () => [
    { type: Http, },
    { type: HttpInterceptorService, },
];
function InterceptableHttpProxyService_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    InterceptableHttpProxyService.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    InterceptableHttpProxyService.ctorParameters;
    /** @type {?} */
    InterceptableHttpProxyService._callStack;
    /** @type {?} */
    InterceptableHttpProxyService.prototype.http;
    /** @type {?} */
    InterceptableHttpProxyService.prototype.httpInterceptorService;
}
export const /** @type {?} */ _proxyTarget = () => null;
// Make sure all Http methods are known for Proxy Polyfill
Object.keys(Http.prototype).forEach(method => _proxyTarget[method] = `Http.${method}`);
/**
 * @param {?} http
 * @param {?} interceptor
 * @return {?}
 */
export function _proxyFactory(http, interceptor) {
    return safeProxy(_proxyTarget, new InterceptableHttpProxyService(http, interceptor));
}
/**
 * @param {?} backend
 * @param {?} options
 * @param {?} interceptor
 * @return {?}
 */
export function proxyFactory(backend, options, interceptor) {
    return _proxyFactory(new Http(backend, options), interceptor);
}
export const /** @type {?} */ InterceptableHttpProxyProviders = [
    {
        provide: Http,
        useFactory: proxyFactory,
        deps: [XHRBackend, RequestOptions, HttpInterceptorService]
    },
    identityFactory(InterceptableHttpProxyService, Http),
];
export const /** @type {?} */ InterceptableHttpProxyNoOverrideProviders = [
    {
        provide: InterceptableHttpProxyService,
        useFactory: _proxyFactory,
        deps: [Http, HttpInterceptorService]
    }
];
//# sourceMappingURL=interceptable-http-proxy.service.js.map
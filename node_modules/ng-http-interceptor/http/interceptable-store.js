/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Injectable } from "@angular/core";
export class InterceptableStoreFactory {
    /**
     * @template D
     * @return {?}
     */
    createStore() {
        return new InterceptableStore();
    }
}
InterceptableStoreFactory.decorators = [
    { type: Injectable },
];
/** @nocollapse */
InterceptableStoreFactory.ctorParameters = () => [];
function InterceptableStoreFactory_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    InterceptableStoreFactory.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    InterceptableStoreFactory.ctorParameters;
}
export const /** @type {?} */ DEFAULT_URL_STORE = '/';
export class InterceptableStore {
    constructor() {
        this.storeMatcher = {};
        this.stores = {};
        this.activeStore = DEFAULT_URL_STORE;
    }
    /**
     * @return {?}
     */
    get store() {
        return this._getStoreSafely(this.activeStore);
    }
    /**
     * @param {?} interceptor
     * @return {?}
     */
    addInterceptor(interceptor) {
        this.store.push(interceptor);
        return this;
    }
    /**
     * @param {?} interceptor
     * @return {?}
     */
    removeInterceptor(interceptor) {
        const /** @type {?} */ idx = this.store.indexOf(interceptor);
        if (idx === -1) {
            return this;
        }
        this.store.splice(idx, 1);
        return this;
    }
    /**
     * @param {?=} interceptors
     * @return {?}
     */
    clearInterceptors(interceptors = []) {
        if (interceptors.length > 0) {
            interceptors.forEach(i => this.removeInterceptor(i));
        }
        else {
            this.store.splice(0);
        }
        return this;
    }
    /**
     * @param {?=} url
     * @return {?}
     */
    setActiveStore(url = DEFAULT_URL_STORE) {
        this.activeStore = String(url);
        if (url instanceof RegExp) {
            this.storeMatcher[this.activeStore] = url;
        }
        return this;
    }
    /**
     * @param {?=} key
     * @return {?}
     */
    getStore(key = DEFAULT_URL_STORE) {
        return this._getStoreSafely(key);
    }
    /**
     * @param {?=} url
     * @return {?}
     */
    getMatchedStores(url = DEFAULT_URL_STORE) {
        const /** @type {?} */ backedUrl = `/${url.replace('/', '\\/')}/`; // Use it for direct string matching
        return Object.keys(this.stores)
            .filter(k => k === url || k === backedUrl || (this.storeMatcher[k] && this.storeMatcher[k].test(url)))
            .filter((k, i, arr) => k !== DEFAULT_URL_STORE && arr.indexOf(k) === i)
            .map(k => this.getStore(k))
            .reduce((stores, store) => [...stores, ...store], this.getStore(DEFAULT_URL_STORE));
    }
    /**
     * @param {?} key
     * @return {?}
     */
    _getStoreSafely(key) {
        return (this.stores[key] || (this.stores[key] = []));
    }
}
function InterceptableStore_tsickle_Closure_declarations() {
    /** @type {?} */
    InterceptableStore.prototype.storeMatcher;
    /** @type {?} */
    InterceptableStore.prototype.stores;
    /** @type {?} */
    InterceptableStore.prototype.activeStore;
}
//# sourceMappingURL=interceptable-store.js.map